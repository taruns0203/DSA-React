<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üîÑ Recursion Visualizer - FAANG Interview Prep</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        color: #e4e4e4;
        padding: 20px;
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 25px;
      }

      h1 {
        font-size: 2.2rem;
        background: linear-gradient(90deg, #00d9ff, #00ff88, #ffaa00);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
      }

      .subtitle {
        color: #8892b0;
        font-size: 1rem;
      }

      .main-layout {
        display: grid;
        grid-template-columns: 300px 1fr 320px;
        gap: 20px;
      }

      .panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      .panel-title {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #00d9ff;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .panel-title::before {
        content: "";
        width: 4px;
        height: 18px;
        background: linear-gradient(180deg, #00d9ff, #00ff88);
        border-radius: 2px;
      }

      /* Controls Panel */
      .controls-section {
        margin-bottom: 20px;
      }

      .input-group {
        margin-bottom: 15px;
      }

      .input-group label {
        display: block;
        margin-bottom: 6px;
        color: #8892b0;
        font-size: 0.85rem;
      }

      .input-row {
        display: flex;
        gap: 10px;
      }

      input[type="number"],
      select {
        flex: 1;
        padding: 10px 14px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 1rem;
        transition: all 0.3s;
      }

      input[type="number"]:focus,
      select:focus {
        outline: none;
        border-color: #00d9ff;
        box-shadow: 0 0 20px rgba(0, 217, 255, 0.2);
      }

      .btn {
        padding: 10px 18px;
        border: none;
        border-radius: 10px;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #00d9ff, #00ff88);
        color: #1a1a2e;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 217, 255, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #e4e4e4;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .btn-group {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
      }

      .btn-icon {
        width: 44px;
        height: 44px;
        padding: 0;
        font-size: 1.2rem;
      }

      .speed-control {
        margin-top: 15px;
      }

      .speed-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
        appearance: none;
        outline: none;
        margin-top: 8px;
      }

      .speed-slider::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #00d9ff, #00ff88);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
      }

      .speed-value {
        text-align: center;
        color: #00ff88;
        font-weight: 600;
        margin-top: 5px;
      }

      /* Algorithm Selection */
      .algo-select {
        width: 100%;
        margin-bottom: 15px;
      }

      /* Stats Display */
      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
      }

      .stat-box {
        background: rgba(0, 0, 0, 0.3);
        padding: 12px;
        border-radius: 10px;
        text-align: center;
      }

      .stat-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: #00ff88;
      }

      .stat-label {
        font-size: 0.75rem;
        color: #8892b0;
        margin-top: 4px;
      }

      /* Visualization Panel */
      .visualization-panel {
        display: flex;
        flex-direction: column;
        min-height: 600px;
      }

      .tree-container {
        flex: 1;
        position: relative;
        overflow: auto;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 20px;
        min-height: 400px;
      }

      .tree-svg {
        width: 100%;
        height: 100%;
        min-height: 350px;
      }

      /* Tree Node Styles */
      .tree-node {
        cursor: pointer;
        transition: all 0.3s;
      }

      .node-circle {
        stroke-width: 3;
        transition: all 0.3s;
      }

      .node-circle.base-case {
        fill: rgba(0, 255, 136, 0.2);
        stroke: #00ff88;
      }

      .node-circle.computing {
        fill: rgba(255, 170, 0, 0.3);
        stroke: #ffaa00;
        animation: pulse 0.8s infinite;
      }

      .node-circle.computed {
        fill: rgba(0, 217, 255, 0.2);
        stroke: #00d9ff;
      }

      .node-circle.cached {
        fill: rgba(255, 0, 128, 0.2);
        stroke: #ff0080;
      }

      .node-circle.pending {
        fill: rgba(255, 255, 255, 0.05);
        stroke: rgba(255, 255, 255, 0.3);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.8;
        }
      }

      .node-text {
        fill: #fff;
        font-size: 14px;
        font-weight: 600;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }

      .node-result {
        fill: #00ff88;
        font-size: 11px;
        font-weight: 600;
        text-anchor: middle;
        pointer-events: none;
      }

      .tree-edge {
        stroke: rgba(255, 255, 255, 0.2);
        stroke-width: 2;
        fill: none;
        transition: all 0.3s;
      }

      .tree-edge.active {
        stroke: #ffaa00;
        stroke-width: 3;
      }

      .tree-edge.complete {
        stroke: #00d9ff;
      }

      /* Code Panel */
      .code-container {
        background: #0d1117;
        border-radius: 12px;
        padding: 15px;
        margin-top: 15px;
        font-family: "Fira Code", "Consolas", monospace;
        font-size: 0.8rem;
        overflow-x: auto;
        max-height: 200px;
        overflow-y: auto;
      }

      .code-line {
        padding: 3px 8px;
        border-radius: 4px;
        white-space: pre;
        transition: all 0.3s;
      }

      .code-line.highlight {
        background: rgba(255, 170, 0, 0.2);
        border-left: 3px solid #ffaa00;
      }

      .code-line .keyword {
        color: #ff79c6;
      }

      .code-line .function {
        color: #50fa7b;
      }

      .code-line .number {
        color: #bd93f9;
      }

      .code-line .comment {
        color: #6272a4;
      }

      .code-line .string {
        color: #f1fa8c;
      }

      /* Right Panel - State & Log */
      .right-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* Call Stack */
      .call-stack {
        max-height: 200px;
        overflow-y: auto;
      }

      .stack-frame {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 10px 12px;
        margin-bottom: 8px;
        border-left: 3px solid #00d9ff;
        transition: all 0.3s;
        font-family: "Fira Code", monospace;
        font-size: 0.85rem;
      }

      .stack-frame.active {
        border-left-color: #ffaa00;
        background: rgba(255, 170, 0, 0.1);
      }

      .stack-frame.returned {
        border-left-color: #00ff88;
        opacity: 0.6;
      }

      .frame-func {
        color: #50fa7b;
        font-weight: 600;
      }

      .frame-param {
        color: #bd93f9;
      }

      .frame-result {
        color: #00ff88;
        margin-left: 8px;
      }

      /* Memo Table */
      .memo-table {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .memo-entry {
        background: rgba(0, 217, 255, 0.1);
        border: 1px solid rgba(0, 217, 255, 0.3);
        border-radius: 8px;
        padding: 6px 10px;
        font-family: "Fira Code", monospace;
        font-size: 0.8rem;
        transition: all 0.3s;
      }

      .memo-entry.new {
        animation: memoAdd 0.5s ease-out;
        background: rgba(0, 255, 136, 0.2);
        border-color: #00ff88;
      }

      .memo-entry.hit {
        animation: memoHit 0.5s ease-out;
        background: rgba(255, 0, 128, 0.2);
        border-color: #ff0080;
      }

      @keyframes memoAdd {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes memoHit {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
          box-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
        }
      }

      .memo-key {
        color: #8892b0;
      }

      .memo-value {
        color: #00ff88;
        font-weight: 600;
      }

      /* Execution Log */
      .log-container {
        flex: 1;
        min-height: 150px;
        max-height: 250px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 12px;
      }

      .log-entry {
        padding: 6px 10px;
        border-radius: 6px;
        margin-bottom: 6px;
        font-size: 0.8rem;
        font-family: "Fira Code", monospace;
        animation: logSlide 0.3s ease-out;
      }

      @keyframes logSlide {
        from {
          transform: translateX(-20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .log-entry.call {
        background: rgba(0, 217, 255, 0.1);
        border-left: 3px solid #00d9ff;
      }

      .log-entry.return {
        background: rgba(0, 255, 136, 0.1);
        border-left: 3px solid #00ff88;
      }

      .log-entry.base {
        background: rgba(255, 170, 0, 0.1);
        border-left: 3px solid #ffaa00;
      }

      .log-entry.cache-hit {
        background: rgba(255, 0, 128, 0.1);
        border-left: 3px solid #ff0080;
      }

      .log-entry.cache-store {
        background: rgba(138, 43, 226, 0.1);
        border-left: 3px solid #8a2be2;
      }

      .log-time {
        color: #6272a4;
        margin-right: 8px;
      }

      /* Current State Display */
      .state-display {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 15px;
      }

      .state-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .state-row:last-child {
        border-bottom: none;
      }

      .state-label {
        color: #8892b0;
        font-size: 0.85rem;
      }

      .state-value {
        font-family: "Fira Code", monospace;
        color: #00ff88;
        font-weight: 600;
      }

      /* Legend */
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.8rem;
      }

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid;
      }

      .legend-dot.computing {
        background: rgba(255, 170, 0, 0.3);
        border-color: #ffaa00;
      }

      .legend-dot.computed {
        background: rgba(0, 217, 255, 0.2);
        border-color: #00d9ff;
      }

      .legend-dot.base-case {
        background: rgba(0, 255, 136, 0.2);
        border-color: #00ff88;
      }

      .legend-dot.cached {
        background: rgba(255, 0, 128, 0.2);
        border-color: #ff0080;
      }

      /* Empty state */
      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #6272a4;
      }

      .empty-state-icon {
        font-size: 3rem;
        margin-bottom: 15px;
      }

      /* Responsive */
      @media (max-width: 1200px) {
        .main-layout {
          grid-template-columns: 1fr;
        }

        .tree-container {
          min-height: 300px;
        }
      }

      /* Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(0, 217, 255, 0.3);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 217, 255, 0.5);
      }

      /* Mode Toggle */
      .mode-toggle {
        display: flex;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 4px;
        margin-bottom: 15px;
      }

      .mode-btn {
        flex: 1;
        padding: 8px;
        border: none;
        background: transparent;
        color: #8892b0;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s;
      }

      .mode-btn.active {
        background: linear-gradient(135deg, #00d9ff, #00ff88);
        color: #1a1a2e;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üîÑ Recursion Visualizer</h1>
        <p class="subtitle">
          Watch recursion unfold step-by-step ‚Ä¢ Perfect for FAANG Interview Prep
        </p>
      </header>

      <div class="main-layout">
        <!-- Left Panel - Controls -->
        <div class="panel">
          <div class="panel-title">Controls</div>

          <div class="controls-section">
            <div class="input-group">
              <label>Algorithm</label>
              <select id="algoSelect" class="algo-select">
                <option value="fibonacci">Fibonacci</option>
                <option value="factorial">Factorial</option>
                <option value="sumArray">Sum Array</option>
                <option value="power">Power (x^n)</option>
              </select>
            </div>

            <div class="mode-toggle">
              <button class="mode-btn active" data-mode="pure" id="pureMode">
                Pure
              </button>
              <button class="mode-btn" data-mode="memo" id="memoMode">
                Memoized
              </button>
            </div>

            <div class="input-group">
              <label>Input Value (n)</label>
              <div class="input-row">
                <input type="number" id="inputN" value="5" min="0" max="10" />
                <button class="btn btn-primary" id="startBtn">‚ñ∂ Start</button>
              </div>
            </div>

            <div id="powerInputs" style="display: none">
              <div class="input-group">
                <label>Base (x)</label>
                <input type="number" id="inputX" value="2" min="1" max="10" />
              </div>
            </div>

            <div class="btn-group">
              <button
                class="btn btn-secondary btn-icon"
                id="stepBackBtn"
                title="Step Back"
              >
                ‚èÆ
              </button>
              <button
                class="btn btn-secondary btn-icon"
                id="playPauseBtn"
                title="Play/Pause"
              >
                ‚ñ∂
              </button>
              <button
                class="btn btn-secondary btn-icon"
                id="stepForwardBtn"
                title="Step Forward"
              >
                ‚è≠
              </button>
              <button
                class="btn btn-secondary btn-icon"
                id="resetBtn"
                title="Reset"
              >
                ‚Ü∫
              </button>
            </div>

            <div class="speed-control">
              <label>Animation Speed</label>
              <input
                type="range"
                class="speed-slider"
                id="speedSlider"
                min="100"
                max="2000"
                value="800"
              />
              <div class="speed-value" id="speedValue">800ms</div>
            </div>
          </div>

          <div class="panel-title">Statistics</div>
          <div class="stats-grid">
            <div class="stat-box">
              <div class="stat-value" id="totalCalls">0</div>
              <div class="stat-label">Total Calls</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="cacheHits">0</div>
              <div class="stat-label">Cache Hits</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="maxDepth">0</div>
              <div class="stat-label">Max Depth</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="currentStep">0</div>
              <div class="stat-label">Current Step</div>
            </div>
          </div>

          <div class="legend">
            <div class="legend-item">
              <div class="legend-dot computing"></div>
              <span>Computing</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot computed"></div>
              <span>Computed</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot base-case"></div>
              <span>Base Case</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot cached"></div>
              <span>Cache Hit</span>
            </div>
          </div>
        </div>

        <!-- Center Panel - Visualization -->
        <div class="panel visualization-panel">
          <div class="panel-title">Recursion Tree</div>
          <div class="tree-container" id="treeContainer">
            <svg class="tree-svg" id="treeSvg">
              <defs>
                <marker
                  id="arrowhead"
                  markerWidth="10"
                  markerHeight="7"
                  refX="9"
                  refY="3.5"
                  orient="auto"
                >
                  <polygon
                    points="0 0, 10 3.5, 0 7"
                    fill="rgba(255,255,255,0.3)"
                  />
                </marker>
              </defs>
            </svg>
          </div>

          <div class="panel-title" style="margin-top: 15px">Code Execution</div>
          <div class="code-container" id="codeContainer">
            <!-- Code will be injected here -->
          </div>
        </div>

        <!-- Right Panel - State & Log -->
        <div class="right-panel">
          <div class="panel">
            <div class="panel-title">Current State</div>
            <div class="state-display">
              <div class="state-row">
                <span class="state-label">Function</span>
                <span class="state-value" id="stateFunc">-</span>
              </div>
              <div class="state-row">
                <span class="state-label">Parameter (n)</span>
                <span class="state-value" id="stateN">-</span>
              </div>
              <div class="state-row">
                <span class="state-label">Depth</span>
                <span class="state-value" id="stateDepth">-</span>
              </div>
              <div class="state-row">
                <span class="state-label">Action</span>
                <span class="state-value" id="stateAction">-</span>
              </div>
              <div class="state-row">
                <span class="state-label">Result</span>
                <span class="state-value" id="stateResult">-</span>
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">Call Stack</div>
            <div class="call-stack" id="callStack">
              <div class="empty-state">
                <div class="empty-state-icon">üìö</div>
                <span>Stack is empty</span>
              </div>
            </div>
          </div>

          <div class="panel" id="memoPanel">
            <div class="panel-title">Memo Cache</div>
            <div class="memo-table" id="memoTable">
              <div class="empty-state" style="padding: 20px">
                <span>No cached values yet</span>
              </div>
            </div>
          </div>

          <div class="panel" style="flex: 1">
            <div class="panel-title">Execution Log</div>
            <div class="log-container" id="logContainer">
              <div class="empty-state">
                <div class="empty-state-icon">üìã</div>
                <span>Press Start to begin</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ==================== STATE ====================
      const state = {
        algorithm: "fibonacci",
        mode: "pure", // 'pure' or 'memo'
        inputN: 5,
        inputX: 2,
        speed: 800,
        isPlaying: false,
        currentStepIndex: 0,
        steps: [],
        memo: {},
        stats: {
          totalCalls: 0,
          cacheHits: 0,
          maxDepth: 0,
        },
        treeNodes: new Map(),
        playInterval: null,
      };

      // ==================== ALGORITHMS ====================
      const algorithms = {
        fibonacci: {
          name: "Fibonacci",
          code: [
            { text: "function fib(n) {", indent: 0 },
            { text: "  // Base cases", indent: 0, type: "comment" },
            { text: "  if (n === 0) return 0;", indent: 0, line: "base0" },
            { text: "  if (n === 1) return 1;", indent: 0, line: "base1" },
            { text: "", indent: 0 },
            { text: "  // Recursive case", indent: 0, type: "comment" },
            {
              text: "  return fib(n-1) + fib(n-2);",
              indent: 0,
              line: "recurse",
            },
            { text: "}", indent: 0 },
          ],
          memoCode: [
            { text: "function fib(n, memo={}) {", indent: 0 },
            { text: "  // Check cache", indent: 0, type: "comment" },
            {
              text: "  if (n in memo) return memo[n];",
              indent: 0,
              line: "cache",
            },
            { text: "", indent: 0 },
            { text: "  // Base cases", indent: 0, type: "comment" },
            { text: "  if (n === 0) return 0;", indent: 0, line: "base0" },
            { text: "  if (n === 1) return 1;", indent: 0, line: "base1" },
            { text: "", indent: 0 },
            { text: "  // Compute & cache", indent: 0, type: "comment" },
            {
              text: "  memo[n] = fib(n-1) + fib(n-2);",
              indent: 0,
              line: "recurse",
            },
            { text: "  return memo[n];", indent: 0, line: "return" },
            { text: "}", indent: 0 },
          ],
          generate: generateFibonacciSteps,
        },
        factorial: {
          name: "Factorial",
          code: [
            { text: "function fact(n) {", indent: 0 },
            { text: "  // Base case", indent: 0, type: "comment" },
            { text: "  if (n <= 1) return 1;", indent: 0, line: "base" },
            { text: "", indent: 0 },
            { text: "  // Recursive case", indent: 0, type: "comment" },
            { text: "  return n * fact(n - 1);", indent: 0, line: "recurse" },
            { text: "}", indent: 0 },
          ],
          memoCode: [
            { text: "function fact(n, memo={}) {", indent: 0 },
            {
              text: "  if (n in memo) return memo[n];",
              indent: 0,
              line: "cache",
            },
            { text: "  if (n <= 1) return 1;", indent: 0, line: "base" },
            { text: "", indent: 0 },
            {
              text: "  memo[n] = n * fact(n - 1);",
              indent: 0,
              line: "recurse",
            },
            { text: "  return memo[n];", indent: 0, line: "return" },
            { text: "}", indent: 0 },
          ],
          generate: generateFactorialSteps,
        },
        sumArray: {
          name: "Sum Array",
          code: [
            { text: "function sum(arr, i = 0) {", indent: 0 },
            { text: "  // Base case", indent: 0, type: "comment" },
            {
              text: "  if (i >= arr.length) return 0;",
              indent: 0,
              line: "base",
            },
            { text: "", indent: 0 },
            { text: "  // Recursive case", indent: 0, type: "comment" },
            {
              text: "  return arr[i] + sum(arr, i+1);",
              indent: 0,
              line: "recurse",
            },
            { text: "}", indent: 0 },
          ],
          memoCode: [
            { text: "function sum(arr, i=0, memo={}) {", indent: 0 },
            {
              text: "  if (i in memo) return memo[i];",
              indent: 0,
              line: "cache",
            },
            {
              text: "  if (i >= arr.length) return 0;",
              indent: 0,
              line: "base",
            },
            { text: "", indent: 0 },
            {
              text: "  memo[i] = arr[i] + sum(arr, i+1);",
              indent: 0,
              line: "recurse",
            },
            { text: "  return memo[i];", indent: 0, line: "return" },
            { text: "}", indent: 0 },
          ],
          generate: generateSumArraySteps,
        },
        power: {
          name: "Power (x^n)",
          code: [
            { text: "function pow(x, n) {", indent: 0 },
            { text: "  // Base case", indent: 0, type: "comment" },
            { text: "  if (n === 0) return 1;", indent: 0, line: "base" },
            { text: "", indent: 0 },
            { text: "  // Recursive case", indent: 0, type: "comment" },
            { text: "  return x * pow(x, n - 1);", indent: 0, line: "recurse" },
            { text: "}", indent: 0 },
          ],
          memoCode: [
            { text: "function pow(x, n, memo={}) {", indent: 0 },
            {
              text: "  if (n in memo) return memo[n];",
              indent: 0,
              line: "cache",
            },
            { text: "  if (n === 0) return 1;", indent: 0, line: "base" },
            { text: "", indent: 0 },
            {
              text: "  memo[n] = x * pow(x, n - 1);",
              indent: 0,
              line: "recurse",
            },
            { text: "  return memo[n];", indent: 0, line: "return" },
            { text: "}", indent: 0 },
          ],
          generate: generatePowerSteps,
        },
      };

      // ==================== STEP GENERATORS ====================
      function generateFibonacciSteps(n, useMemo) {
        const steps = [];
        const memo = {};
        let callId = 0;
        let totalCalls = 0;
        let cacheHits = 0;
        let maxDepth = 0;

        function fib(n, depth, parentId) {
          const nodeId = callId++;
          totalCalls++;
          maxDepth = Math.max(maxDepth, depth);

          steps.push({
            type: "call",
            nodeId,
            parentId,
            n,
            depth,
            line: null,
            action: `Calling fib(${n})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          // Check memo
          if (useMemo && n in memo) {
            cacheHits++;
            steps.push({
              type: "cache-hit",
              nodeId,
              n,
              depth,
              result: memo[n],
              line: "cache",
              action: `Cache HIT! fib(${n}) = ${memo[n]}`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return memo[n];
          }

          // Base cases
          if (n === 0) {
            steps.push({
              type: "base-case",
              nodeId,
              n,
              depth,
              result: 0,
              line: "base0",
              action: `Base case: fib(0) = 0`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return 0;
          }
          if (n === 1) {
            steps.push({
              type: "base-case",
              nodeId,
              n,
              depth,
              result: 1,
              line: "base1",
              action: `Base case: fib(1) = 1`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return 1;
          }

          steps.push({
            type: "computing",
            nodeId,
            n,
            depth,
            line: "recurse",
            action: `Computing fib(${n - 1}) + fib(${n - 2})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          const left = fib(n - 1, depth + 1, nodeId);
          const right = fib(n - 2, depth + 1, nodeId);
          const result = left + right;

          if (useMemo) {
            memo[n] = result;
            steps.push({
              type: "cache-store",
              nodeId,
              n,
              depth,
              result,
              line: "return",
              action: `Storing memo[${n}] = ${result}`,
              totalCalls,
              cacheHits,
              maxDepth,
              memoSnapshot: { ...memo },
            });
          }

          steps.push({
            type: "return",
            nodeId,
            n,
            depth,
            result,
            line: useMemo ? "return" : "recurse",
            action: `Returning fib(${n}) = ${result}`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          return result;
        }

        fib(n, 0, null);
        return steps;
      }

      function generateFactorialSteps(n, useMemo) {
        const steps = [];
        const memo = {};
        let callId = 0;
        let totalCalls = 0;
        let cacheHits = 0;
        let maxDepth = 0;

        function fact(n, depth, parentId) {
          const nodeId = callId++;
          totalCalls++;
          maxDepth = Math.max(maxDepth, depth);

          steps.push({
            type: "call",
            nodeId,
            parentId,
            n,
            depth,
            line: null,
            action: `Calling fact(${n})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          if (useMemo && n in memo) {
            cacheHits++;
            steps.push({
              type: "cache-hit",
              nodeId,
              n,
              depth,
              result: memo[n],
              line: "cache",
              action: `Cache HIT! fact(${n}) = ${memo[n]}`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return memo[n];
          }

          if (n <= 1) {
            steps.push({
              type: "base-case",
              nodeId,
              n,
              depth,
              result: 1,
              line: "base",
              action: `Base case: fact(${n}) = 1`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return 1;
          }

          steps.push({
            type: "computing",
            nodeId,
            n,
            depth,
            line: "recurse",
            action: `Computing ${n} √ó fact(${n - 1})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          const subResult = fact(n - 1, depth + 1, nodeId);
          const result = n * subResult;

          if (useMemo) {
            memo[n] = result;
            steps.push({
              type: "cache-store",
              nodeId,
              n,
              depth,
              result,
              line: "return",
              action: `Storing memo[${n}] = ${result}`,
              totalCalls,
              cacheHits,
              maxDepth,
              memoSnapshot: { ...memo },
            });
          }

          steps.push({
            type: "return",
            nodeId,
            n,
            depth,
            result,
            line: useMemo ? "return" : "recurse",
            action: `Returning fact(${n}) = ${result}`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          return result;
        }

        fact(n, 0, null);
        return steps;
      }

      function generateSumArraySteps(n, useMemo) {
        const arr = Array.from({ length: n }, (_, i) => i + 1);
        const steps = [];
        const memo = {};
        let callId = 0;
        let totalCalls = 0;
        let cacheHits = 0;
        let maxDepth = 0;

        function sum(i, depth, parentId) {
          const nodeId = callId++;
          totalCalls++;
          maxDepth = Math.max(maxDepth, depth);

          steps.push({
            type: "call",
            nodeId,
            parentId,
            n: i,
            depth,
            line: null,
            action: `Calling sum(arr, ${i})`,
            totalCalls,
            cacheHits,
            maxDepth,
            extra: `arr[${i}] = ${arr[i] || "out of bounds"}`,
          });

          if (useMemo && i in memo) {
            cacheHits++;
            steps.push({
              type: "cache-hit",
              nodeId,
              n: i,
              depth,
              result: memo[i],
              line: "cache",
              action: `Cache HIT! sum(${i}) = ${memo[i]}`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return memo[i];
          }

          if (i >= arr.length) {
            steps.push({
              type: "base-case",
              nodeId,
              n: i,
              depth,
              result: 0,
              line: "base",
              action: `Base case: index ${i} >= length, return 0`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return 0;
          }

          steps.push({
            type: "computing",
            nodeId,
            n: i,
            depth,
            line: "recurse",
            action: `Computing arr[${i}] + sum(arr, ${i + 1})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          const subResult = sum(i + 1, depth + 1, nodeId);
          const result = arr[i] + subResult;

          if (useMemo) {
            memo[i] = result;
            steps.push({
              type: "cache-store",
              nodeId,
              n: i,
              depth,
              result,
              line: "return",
              action: `Storing memo[${i}] = ${result}`,
              totalCalls,
              cacheHits,
              maxDepth,
              memoSnapshot: { ...memo },
            });
          }

          steps.push({
            type: "return",
            nodeId,
            n: i,
            depth,
            result,
            line: useMemo ? "return" : "recurse",
            action: `Returning sum(${i}) = ${arr[i]} + ${subResult} = ${result}`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          return result;
        }

        sum(0, 0, null);
        return steps;
      }

      function generatePowerSteps(n, useMemo) {
        const x = state.inputX;
        const steps = [];
        const memo = {};
        let callId = 0;
        let totalCalls = 0;
        let cacheHits = 0;
        let maxDepth = 0;

        function pow(exp, depth, parentId) {
          const nodeId = callId++;
          totalCalls++;
          maxDepth = Math.max(maxDepth, depth);

          steps.push({
            type: "call",
            nodeId,
            parentId,
            n: exp,
            depth,
            line: null,
            action: `Calling pow(${x}, ${exp})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          if (useMemo && exp in memo) {
            cacheHits++;
            steps.push({
              type: "cache-hit",
              nodeId,
              n: exp,
              depth,
              result: memo[exp],
              line: "cache",
              action: `Cache HIT! pow(${x}, ${exp}) = ${memo[exp]}`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return memo[exp];
          }

          if (exp === 0) {
            steps.push({
              type: "base-case",
              nodeId,
              n: exp,
              depth,
              result: 1,
              line: "base",
              action: `Base case: pow(${x}, 0) = 1`,
              totalCalls,
              cacheHits,
              maxDepth,
            });
            return 1;
          }

          steps.push({
            type: "computing",
            nodeId,
            n: exp,
            depth,
            line: "recurse",
            action: `Computing ${x} √ó pow(${x}, ${exp - 1})`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          const subResult = pow(exp - 1, depth + 1, nodeId);
          const result = x * subResult;

          if (useMemo) {
            memo[exp] = result;
            steps.push({
              type: "cache-store",
              nodeId,
              n: exp,
              depth,
              result,
              line: "return",
              action: `Storing memo[${exp}] = ${result}`,
              totalCalls,
              cacheHits,
              maxDepth,
              memoSnapshot: { ...memo },
            });
          }

          steps.push({
            type: "return",
            nodeId,
            n: exp,
            depth,
            result,
            line: useMemo ? "return" : "recurse",
            action: `Returning pow(${x}, ${exp}) = ${result}`,
            totalCalls,
            cacheHits,
            maxDepth,
          });

          return result;
        }

        pow(n, 0, null);
        return steps;
      }

      // ==================== RENDERING ====================
      function renderCode() {
        const algo = algorithms[state.algorithm];
        const code = state.mode === "memo" ? algo.memoCode : algo.code;
        const container = document.getElementById("codeContainer");

        container.innerHTML = code
          .map((line, i) => {
            let text = line.text;
            // Syntax highlighting
            text = text.replace(
              /\b(function|if|return|in|const|let|var)\b/g,
              '<span class="keyword">$1</span>',
            );
            text = text.replace(
              /\b(fib|fact|sum|pow)\b/g,
              '<span class="function">$1</span>',
            );
            text = text.replace(/\b(\d+)\b/g, '<span class="number">$1</span>');
            if (line.type === "comment") {
              text = `<span class="comment">${text}</span>`;
            }
            return `<div class="code-line" data-line="${line.line || ""}">${text}</div>`;
          })
          .join("");
      }

      function highlightCodeLine(lineName) {
        document.querySelectorAll(".code-line").forEach((el) => {
          el.classList.remove("highlight");
          if (el.dataset.line === lineName) {
            el.classList.add("highlight");
          }
        });
      }

      function renderTree() {
        const svg = document.getElementById("treeSvg");
        const container = document.getElementById("treeContainer");

        // Calculate tree layout
        const nodes = [];
        const edges = [];
        const nodePositions = new Map();

        // Find all call steps to build tree structure
        const callSteps = state.steps.filter((s) => s.type === "call");
        if (callSteps.length === 0) return;

        // Calculate positions using level-based layout
        const levels = new Map();
        const nodeChildren = new Map();

        callSteps.forEach((step) => {
          if (!levels.has(step.depth)) {
            levels.set(step.depth, []);
          }
          levels.get(step.depth).push(step);

          if (step.parentId !== null) {
            if (!nodeChildren.has(step.parentId)) {
              nodeChildren.set(step.parentId, []);
            }
            nodeChildren.get(step.parentId).push(step.nodeId);
          }
        });

        const maxDepth = Math.max(...levels.keys()) + 1;
        const nodeRadius = 28;
        const levelHeight = 80;
        const minNodeSpacing = 70;

        // Calculate width needed for each level
        const levelWidths = new Map();
        for (let d = maxDepth - 1; d >= 0; d--) {
          const levelNodes = levels.get(d) || [];
          let width = 0;
          levelNodes.forEach((node) => {
            const children = nodeChildren.get(node.nodeId) || [];
            if (children.length === 0) {
              width += minNodeSpacing;
            } else {
              let childWidth = 0;
              children.forEach((childId) => {
                const childNode = callSteps.find((s) => s.nodeId === childId);
                childWidth += levelWidths.get(childId) || minNodeSpacing;
              });
              levelWidths.set(node.nodeId, childWidth);
              width += childWidth;
            }
          });
          if (d === 0) levelWidths.set("root", width);
        }

        // Position nodes
        function positionNode(nodeId, left, right, depth) {
          const node = callSteps.find((s) => s.nodeId === nodeId);
          if (!node) return;

          const x = (left + right) / 2;
          const y = depth * levelHeight + 50;
          nodePositions.set(nodeId, { x, y, node });

          const children = nodeChildren.get(nodeId) || [];
          if (children.length > 0) {
            let currentLeft = left;
            children.forEach((childId) => {
              const childWidth = levelWidths.get(childId) || minNodeSpacing;
              positionNode(
                childId,
                currentLeft,
                currentLeft + childWidth,
                depth + 1,
              );
              currentLeft += childWidth;
            });
          }
        }

        const rootWidth = Math.max(
          levelWidths.get("root") || 200,
          container.clientWidth - 40,
        );
        const rootNode = callSteps.find((s) => s.parentId === null);
        if (rootNode) {
          positionNode(rootNode.nodeId, 0, rootWidth, 0);
        }

        // Update SVG size
        const svgWidth = rootWidth + 40;
        const svgHeight = maxDepth * levelHeight + 100;
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        svg.style.minWidth = svgWidth + "px";
        svg.style.minHeight = svgHeight + "px";

        // Build SVG content
        let svgContent =
          '<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="rgba(255,255,255,0.3)" /></marker></defs>';

        // Draw edges
        nodePositions.forEach((pos, nodeId) => {
          const children = nodeChildren.get(nodeId) || [];
          children.forEach((childId) => {
            const childPos = nodePositions.get(childId);
            if (childPos) {
              const edgeState = getEdgeState(nodeId, childId);
              svgContent += `<path class="tree-edge ${edgeState}" d="M ${pos.x + 20} ${pos.y + nodeRadius} Q ${pos.x + 20} ${(pos.y + childPos.y) / 2} ${childPos.x + 20} ${childPos.y - nodeRadius}" />`;
            }
          });
        });

        // Draw nodes
        nodePositions.forEach((pos, nodeId) => {
          const nodeState = getNodeState(nodeId);
          const result = getNodeResult(nodeId);
          const funcName = getFunctionName();

          svgContent += `
                    <g class="tree-node" transform="translate(${pos.x - 8}, ${pos.y - nodeRadius})">
                        <circle class="node-circle ${nodeState}" cx="${nodeRadius}" cy="${nodeRadius}" r="${nodeRadius}" />
                        <text class="node-text" x="${nodeRadius}" y="${nodeRadius}">${funcName}(${pos.node.n})</text>
                        ${result !== null ? `<text class="node-result" x="${nodeRadius}" y="${nodeRadius + 38}">= ${result}</text>` : ""}
                    </g>
                `;
        });

        svg.innerHTML = svgContent;
        state.treeNodes = nodePositions;
      }

      function getFunctionName() {
        const names = {
          fibonacci: "fib",
          factorial: "fact",
          sumArray: "sum",
          power: "pow",
        };
        return names[state.algorithm] || "f";
      }

      function getNodeState(nodeId) {
        const currentStep = state.steps[state.currentStepIndex];
        if (!currentStep) return "pending";

        // Find all steps for this node up to current step
        const nodeSteps = state.steps
          .slice(0, state.currentStepIndex + 1)
          .filter((s) => s.nodeId === nodeId);

        if (nodeSteps.length === 0) return "pending";

        const lastStep = nodeSteps[nodeSteps.length - 1];

        if (lastStep.type === "cache-hit") return "cached";
        if (lastStep.type === "base-case") return "base-case";
        if (lastStep.type === "return" || lastStep.type === "cache-store")
          return "computed";
        if (
          currentStep.nodeId === nodeId &&
          (currentStep.type === "call" || currentStep.type === "computing")
        ) {
          return "computing";
        }
        if (lastStep.type === "call" || lastStep.type === "computing")
          return "computing";

        return "pending";
      }

      function getNodeResult(nodeId) {
        const nodeSteps = state.steps
          .slice(0, state.currentStepIndex + 1)
          .filter((s) => s.nodeId === nodeId);

        for (let i = nodeSteps.length - 1; i >= 0; i--) {
          if (nodeSteps[i].result !== undefined) {
            return nodeSteps[i].result;
          }
        }
        return null;
      }

      function getEdgeState(parentId, childId) {
        const childSteps = state.steps
          .slice(0, state.currentStepIndex + 1)
          .filter((s) => s.nodeId === childId);

        if (childSteps.length === 0) return "";

        const hasReturned = childSteps.some(
          (s) =>
            s.type === "return" ||
            s.type === "base-case" ||
            s.type === "cache-hit",
        );

        if (hasReturned) return "complete";

        const currentStep = state.steps[state.currentStepIndex];
        if (currentStep && currentStep.nodeId === childId) return "active";

        return "";
      }

      function renderCallStack() {
        const container = document.getElementById("callStack");
        const stack = [];
        const funcName = getFunctionName();

        // Build stack from steps
        for (
          let i = 0;
          i <= state.currentStepIndex && i < state.steps.length;
          i++
        ) {
          const step = state.steps[i];
          if (step.type === "call") {
            stack.push({
              nodeId: step.nodeId,
              n: step.n,
              result: null,
              active: false,
            });
          } else if (
            step.type === "return" ||
            step.type === "base-case" ||
            step.type === "cache-hit"
          ) {
            const frame = stack.find((f) => f.nodeId === step.nodeId);
            if (frame) {
              frame.result = step.result;
            }
          }
        }

        // Mark top frame as active
        const activeFrames = stack.filter((f) => f.result === null);
        if (activeFrames.length > 0) {
          activeFrames[activeFrames.length - 1].active = true;
        }

        if (stack.length === 0) {
          container.innerHTML = `<div class="empty-state"><div class="empty-state-icon">üìö</div><span>Stack is empty</span></div>`;
          return;
        }

        container.innerHTML = stack
          .map(
            (frame, i) => `
                <div class="stack-frame ${frame.active ? "active" : ""} ${frame.result !== null ? "returned" : ""}">
                    <span class="frame-func">${funcName}</span>(<span class="frame-param">${frame.n}</span>)
                    ${frame.result !== null ? `<span class="frame-result">‚Üí ${frame.result}</span>` : ""}
                </div>
            `,
          )
          .reverse()
          .join("");
      }

      function renderMemo() {
        const container = document.getElementById("memoTable");
        const panel = document.getElementById("memoPanel");

        if (state.mode !== "memo") {
          panel.style.display = "none";
          return;
        }
        panel.style.display = "block";

        // Get current memo state
        const memo = {};
        const recentlyAdded = new Set();
        const currentStep = state.steps[state.currentStepIndex];

        for (
          let i = 0;
          i <= state.currentStepIndex && i < state.steps.length;
          i++
        ) {
          const step = state.steps[i];
          if (step.memoSnapshot) {
            Object.assign(memo, step.memoSnapshot);
            if (i === state.currentStepIndex) {
              Object.keys(step.memoSnapshot).forEach((k) =>
                recentlyAdded.add(k),
              );
            }
          }
        }

        const entries = Object.entries(memo);
        if (entries.length === 0) {
          container.innerHTML = `<div class="empty-state" style="padding: 20px;"><span>No cached values yet</span></div>`;
          return;
        }

        const isHit = currentStep && currentStep.type === "cache-hit";

        container.innerHTML = entries
          .map(([key, value]) => {
            let className = "memo-entry";
            if (recentlyAdded.has(key) && !isHit) className += " new";
            if (isHit && parseInt(key) === currentStep.n) className += " hit";
            return `<div class="${className}"><span class="memo-key">[${key}]</span> = <span class="memo-value">${value}</span></div>`;
          })
          .join("");
      }

      function renderLog() {
        const container = document.getElementById("logContainer");
        const logs = state.steps.slice(0, state.currentStepIndex + 1);

        if (logs.length === 0) {
          container.innerHTML = `<div class="empty-state"><div class="empty-state-icon">üìã</div><span>Press Start to begin</span></div>`;
          return;
        }

        container.innerHTML = logs
          .map((step, i) => {
            const time = String(i + 1).padStart(3, "0");
            let className = "log-entry";

            if (step.type === "call") className += " call";
            else if (step.type === "return") className += " return";
            else if (step.type === "base-case") className += " base";
            else if (step.type === "cache-hit") className += " cache-hit";
            else if (step.type === "cache-store") className += " cache-store";

            return `<div class="${className}"><span class="log-time">#${time}</span>${step.action}</div>`;
          })
          .join("");

        container.scrollTop = container.scrollHeight;
      }

      function renderState() {
        const step = state.steps[state.currentStepIndex];
        const funcName = getFunctionName();

        document.getElementById("stateFunc").textContent = step
          ? `${funcName}()`
          : "-";
        document.getElementById("stateN").textContent = step ? step.n : "-";
        document.getElementById("stateDepth").textContent = step
          ? step.depth
          : "-";
        document.getElementById("stateAction").textContent = step
          ? step.type
          : "-";
        document.getElementById("stateResult").textContent =
          step?.result !== undefined ? step.result : "-";

        // Stats
        document.getElementById("totalCalls").textContent =
          step?.totalCalls || 0;
        document.getElementById("cacheHits").textContent = step?.cacheHits || 0;
        document.getElementById("maxDepth").textContent = step?.maxDepth || 0;
        document.getElementById("currentStep").textContent =
          `${state.currentStepIndex + 1}/${state.steps.length}`;

        // Highlight code
        highlightCodeLine(step?.line || "");
      }

      function render() {
        renderTree();
        renderCallStack();
        renderMemo();
        renderLog();
        renderState();
      }

      // ==================== CONTROLS ====================
      function start() {
        const algo = algorithms[state.algorithm];
        state.steps = algo.generate(state.inputN, state.mode === "memo");
        state.currentStepIndex = 0;
        state.isPlaying = false;
        clearInterval(state.playInterval);

        renderCode();
        render();
      }

      function stepForward() {
        if (state.currentStepIndex < state.steps.length - 1) {
          state.currentStepIndex++;
          render();
        } else {
          pause();
        }
      }

      function stepBack() {
        if (state.currentStepIndex > 0) {
          state.currentStepIndex--;
          render();
        }
      }

      function play() {
        if (state.steps.length === 0) {
          start();
        }
        state.isPlaying = true;
        document.getElementById("playPauseBtn").textContent = "‚è∏";

        state.playInterval = setInterval(() => {
          if (state.currentStepIndex < state.steps.length - 1) {
            stepForward();
          } else {
            pause();
          }
        }, state.speed);
      }

      function pause() {
        state.isPlaying = false;
        document.getElementById("playPauseBtn").textContent = "‚ñ∂";
        clearInterval(state.playInterval);
      }

      function togglePlayPause() {
        if (state.isPlaying) {
          pause();
        } else {
          play();
        }
      }

      function reset() {
        pause();
        state.steps = [];
        state.currentStepIndex = 0;
        state.treeNodes.clear();

        document.getElementById("treeSvg").innerHTML = "";
        document.getElementById("callStack").innerHTML =
          `<div class="empty-state"><div class="empty-state-icon">üìö</div><span>Stack is empty</span></div>`;
        document.getElementById("memoTable").innerHTML =
          `<div class="empty-state" style="padding: 20px;"><span>No cached values yet</span></div>`;
        document.getElementById("logContainer").innerHTML =
          `<div class="empty-state"><div class="empty-state-icon">üìã</div><span>Press Start to begin</span></div>`;

        renderCode();
        renderState();
      }

      // ==================== EVENT LISTENERS ====================
      document.getElementById("algoSelect").addEventListener("change", (e) => {
        state.algorithm = e.target.value;
        document.getElementById("powerInputs").style.display =
          state.algorithm === "power" ? "block" : "none";
        reset();
      });

      document.getElementById("pureMode").addEventListener("click", () => {
        state.mode = "pure";
        document.getElementById("pureMode").classList.add("active");
        document.getElementById("memoMode").classList.remove("active");
        reset();
      });

      document.getElementById("memoMode").addEventListener("click", () => {
        state.mode = "memo";
        document.getElementById("memoMode").classList.add("active");
        document.getElementById("pureMode").classList.remove("active");
        reset();
      });

      document.getElementById("inputN").addEventListener("change", (e) => {
        state.inputN = Math.max(0, Math.min(10, parseInt(e.target.value) || 0));
        e.target.value = state.inputN;
      });

      document.getElementById("inputX").addEventListener("change", (e) => {
        state.inputX = Math.max(1, Math.min(10, parseInt(e.target.value) || 2));
        e.target.value = state.inputX;
      });

      document.getElementById("speedSlider").addEventListener("input", (e) => {
        state.speed = parseInt(e.target.value);
        document.getElementById("speedValue").textContent = state.speed + "ms";
        if (state.isPlaying) {
          pause();
          play();
        }
      });

      document.getElementById("startBtn").addEventListener("click", start);
      document
        .getElementById("playPauseBtn")
        .addEventListener("click", togglePlayPause);
      document
        .getElementById("stepForwardBtn")
        .addEventListener("click", stepForward);
      document
        .getElementById("stepBackBtn")
        .addEventListener("click", stepBack);
      document.getElementById("resetBtn").addEventListener("click", reset);

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.target.tagName === "INPUT") return;

        switch (e.key) {
          case " ":
            e.preventDefault();
            togglePlayPause();
            break;
          case "ArrowRight":
            stepForward();
            break;
          case "ArrowLeft":
            stepBack();
            break;
          case "r":
            reset();
            break;
          case "Enter":
            start();
            break;
        }
      });

      // Initialize
      renderCode();
      renderState();
    </script>
  </body>
</html>
