<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Box Pushing - Optimal 0-1 BFS Solution</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        padding: 20px;
      }

      .whiteboard {
        background: #fff;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 30px;
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 25px;
      }

      h1 {
        color: #1a1a2e;
        font-size: 2rem;
        margin-bottom: 8px;
      }

      .optimal-badge {
        display: inline-block;
        background: linear-gradient(135deg, #f39c12, #e74c3c);
        color: white;
        padding: 6px 16px;
        border-radius: 25px;
        font-size: 0.85rem;
        font-weight: bold;
        margin-left: 10px;
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0%,
        100% {
          box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
        }
      }

      .subtitle {
        color: #7f8c8d;
        font-size: 1rem;
      }

      .key-insight {
        background: linear-gradient(135deg, #fff9e6, #fff3cd);
        border: 2px solid #f39c12;
        border-radius: 12px;
        padding: 15px 20px;
        margin-bottom: 25px;
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .key-insight-icon {
        font-size: 2rem;
      }

      .key-insight-text {
        flex: 1;
      }

      .key-insight-title {
        font-weight: bold;
        color: #d68910;
        margin-bottom: 5px;
      }

      .key-insight-desc {
        color: #7f6c3e;
        font-size: 0.95rem;
      }

      .cost-badges {
        display: flex;
        gap: 15px;
        margin-top: 8px;
      }

      .cost-badge {
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 0.85rem;
        font-weight: bold;
      }

      .cost-0 {
        background: #d4edda;
        color: #155724;
        border: 2px solid #28a745;
      }

      .cost-1 {
        background: #f8d7da;
        color: #721c24;
        border: 2px solid #dc3545;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 1.3fr;
        gap: 25px;
      }

      .panel {
        background: #f8f9fa;
        border-radius: 15px;
        padding: 20px;
        border: 2px solid #e9ecef;
      }

      .section-title {
        font-size: 1.1rem;
        color: #1a1a2e;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 3px solid #e74c3c;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .section-icon {
        width: 32px;
        height: 32px;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 1rem;
      }

      /* Grid */
      .grid-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 20px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(6, 50px);
        gap: 2px;
        background: #1a1a2e;
        padding: 4px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .cell {
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: bold;
        border-radius: 6px;
        transition: all 0.3s ease;
        position: relative;
      }

      .cell.wall {
        background: #2c3e50;
        color: #2c3e50;
      }
      .cell.floor {
        background: #ecf0f1;
        color: #bdc3c7;
      }
      .cell.player {
        background: #3498db;
        color: white;
        box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
      }
      .cell.box {
        background: #e74c3c;
        color: white;
        box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
      }
      .cell.target {
        background: #2ecc71;
        color: white;
      }
      .cell.box-on-target {
        background: #f39c12;
        color: white;
        animation: winPulse 0.5s infinite;
      }
      .cell.walk-highlight {
        background: #74b9ff;
        border: 3px solid #0984e3;
      }
      .cell.push-highlight {
        background: #fab1a0;
        border: 3px solid #e74c3c;
      }

      @keyframes winPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .legend {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 15px;
        padding: 12px;
        background: white;
        border-radius: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.8rem;
        color: #555;
      }

      .legend-box {
        width: 20px;
        height: 20px;
        border-radius: 4px;
      }

      /* Controls */
      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 24px;
        font-size: 0.95rem;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }
      button:active {
        transform: translateY(0);
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }
      .btn-success {
        background: linear-gradient(135deg, #00b894, #00cec9);
        color: white;
      }
      .btn-warning {
        background: linear-gradient(135deg, #fdcb6e, #f39c12);
        color: white;
      }
      .btn-danger {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
      }

      /* State Panel */
      .state-panel {
        background: white;
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .state-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }

      .state-item {
        padding: 12px;
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border-radius: 10px;
        border-left: 4px solid #e74c3c;
      }

      .state-label {
        font-size: 0.75rem;
        color: #7f8c8d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .state-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #1a1a2e;
        font-family: "Courier New", monospace;
      }

      .state-value.highlight {
        color: #e74c3c;
        background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
        padding: 2px 10px;
        border-radius: 6px;
      }

      /* Deque Visualization - The Star of the Show */
      .deque-container {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        border: 3px solid #e74c3c;
      }

      .deque-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .deque-title {
        font-weight: bold;
        color: #1a1a2e;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .deque-size {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85rem;
      }

      .deque-labels {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        padding: 0 10px;
      }

      .deque-label {
        font-size: 0.8rem;
        font-weight: bold;
        padding: 4px 12px;
        border-radius: 15px;
      }

      .deque-label.front {
        background: #d4edda;
        color: #155724;
      }

      .deque-label.back {
        background: #f8d7da;
        color: #721c24;
      }

      .deque-visual {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 15px;
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border-radius: 10px;
        min-height: 80px;
        overflow-x: auto;
      }

      .deque-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px 12px;
        background: white;
        border-radius: 8px;
        font-family: "Courier New", monospace;
        font-size: 0.75rem;
        min-width: 90px;
        border: 2px solid #ddd;
        transition: all 0.3s;
      }

      .deque-item.current {
        border: 3px solid #f39c12;
        background: linear-gradient(135deg, #fff9e6, #fff3cd);
        transform: scale(1.05);
      }

      .deque-item.walk {
        border-color: #28a745;
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
      }

      .deque-item.push {
        border-color: #dc3545;
        background: linear-gradient(135deg, #f8d7da, #f5c6cb);
      }

      .deque-item.new-front {
        animation: slideFromLeft 0.5s ease;
      }

      .deque-item.new-back {
        animation: slideFromRight 0.5s ease;
      }

      @keyframes slideFromLeft {
        from {
          transform: translateX(-50px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideFromRight {
        from {
          transform: translateX(50px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .deque-item-pos {
        font-weight: bold;
        color: #2c3e50;
      }

      .deque-item-cost {
        font-size: 0.7rem;
        padding: 2px 8px;
        border-radius: 10px;
        margin-top: 4px;
      }

      .cost-tag-0 {
        background: #28a745;
        color: white;
      }

      .cost-tag-1 {
        background: #dc3545;
        color: white;
      }

      .deque-arrow {
        font-size: 1.5rem;
        color: #bdc3c7;
      }

      .deque-explanation {
        margin-top: 15px;
        padding: 12px;
        background: #e8f4fd;
        border-radius: 8px;
        font-size: 0.9rem;
        color: #0c5460;
        border-left: 4px solid #17a2b8;
      }

      /* Action indicator */
      .action-indicator {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 15px 0;
      }

      .action-box {
        padding: 12px 20px;
        border-radius: 10px;
        font-weight: bold;
        opacity: 0.4;
        transition: all 0.3s;
      }

      .action-box.active {
        opacity: 1;
        transform: scale(1.05);
      }

      .action-walk {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        color: #155724;
        border: 2px solid #28a745;
      }

      .action-push {
        background: linear-gradient(135deg, #f8d7da, #f5c6cb);
        color: #721c24;
        border: 2px solid #dc3545;
      }

      /* Explanation */
      .explanation-box {
        background: linear-gradient(135deg, #e8f4fd, #d1ecf1);
        border-radius: 12px;
        padding: 15px;
        margin-top: 15px;
        border-left: 5px solid #17a2b8;
      }

      .explanation-title {
        font-weight: bold;
        color: #0c5460;
        margin-bottom: 8px;
        font-size: 1rem;
      }

      .explanation-text {
        color: #2d3436;
        line-height: 1.7;
        font-size: 0.95rem;
      }

      .code-hl {
        background: rgba(255, 255, 255, 0.7);
        padding: 2px 8px;
        border-radius: 4px;
        font-family: "Courier New", monospace;
        font-size: 0.9rem;
      }

      /* Invariant Box */
      .invariant-box {
        background: linear-gradient(135deg, #fff3e6, #ffe6cc);
        border: 2px solid #f39c12;
        border-radius: 12px;
        padding: 15px;
        margin-top: 15px;
      }

      .invariant-title {
        font-weight: bold;
        color: #d68910;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .invariant-text {
        color: #7f6c3e;
        font-size: 0.9rem;
        line-height: 1.5;
      }

      /* Message */
      .message-box {
        padding: 15px;
        border-radius: 12px;
        margin: 15px 0;
        text-align: center;
        font-weight: 600;
        display: none;
      }

      .message-box.success {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        color: #155724;
        display: block;
        animation: celebrate 0.5s ease;
      }

      @keyframes celebrate {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
      }

      /* Pseudocode */
      .pseudocode {
        background: #1a1a2e;
        color: #ecf0f1;
        padding: 20px;
        border-radius: 12px;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
        line-height: 1.8;
        margin-top: 15px;
        overflow-x: auto;
      }

      .pseudocode .keyword {
        color: #e74c3c;
      }
      .pseudocode .function {
        color: #2ecc71;
      }
      .pseudocode .comment {
        color: #636e72;
        font-style: italic;
      }
      .pseudocode .highlight-line {
        background: rgba(231, 76, 60, 0.3);
        display: block;
        margin: 0 -20px;
        padding: 0 20px;
      }
      .pseudocode .walk-line {
        background: rgba(40, 167, 69, 0.3);
      }
      .pseudocode .push-line {
        background: rgba(220, 53, 69, 0.3);
      }

      /* Speed */
      .speed-control {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        margin: 15px 0;
        padding: 12px;
        background: white;
        border-radius: 10px;
      }

      /* Footer */
      .footer-info {
        margin-top: 25px;
        padding: 20px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 15px;
        text-align: center;
        color: white;
      }

      .footer-title {
        font-size: 1.1rem;
        margin-bottom: 15px;
      }

      .complexity-grid {
        display: flex;
        justify-content: center;
        gap: 50px;
        flex-wrap: wrap;
      }

      .complexity-item {
        text-align: center;
      }

      .complexity-label {
        font-size: 0.8rem;
        opacity: 0.8;
      }

      .complexity-value {
        font-size: 1.3rem;
        font-weight: bold;
        font-family: "Courier New", monospace;
        color: #f39c12;
      }

      /* Responsive */
      @media (max-width: 1200px) {
        .main-container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="whiteboard">
      <div class="header">
        <h1>
          üì¶ Box Pushing Problem <span class="optimal-badge">‚≠ê OPTIMAL</span>
        </h1>
        <p class="subtitle">
          0-1 BFS using Deque - The most efficient solution
        </p>
      </div>

      <div class="key-insight">
        <div class="key-insight-icon">üí°</div>
        <div class="key-insight-text">
          <div class="key-insight-title">
            Key Insight: Two Types of Edges with Different Costs
          </div>
          <div class="key-insight-desc">
            Walking costs 0 (free), Pushing costs 1. Use a
            <strong>deque</strong> instead of a regular queue!
          </div>
          <div class="cost-badges">
            <span class="cost-badge cost-0"
              >üö∂ WALK = Cost 0 ‚Üí Add to FRONT</span
            >
            <span class="cost-badge cost-1"
              >üì¶ PUSH = Cost 1 ‚Üí Add to BACK</span
            >
          </div>
        </div>
      </div>

      <div class="main-container">
        <div class="panel">
          <div class="section-title">
            <div class="section-icon">üéÆ</div>
            Game State
          </div>

          <div class="grid-container">
            <div class="grid" id="grid"></div>
            <div class="legend">
              <div class="legend-item">
                <div class="legend-box" style="background: #2c3e50"></div>
                <span>Wall</span>
              </div>
              <div class="legend-item">
                <div class="legend-box" style="background: #3498db"></div>
                <span>Player</span>
              </div>
              <div class="legend-item">
                <div class="legend-box" style="background: #e74c3c"></div>
                <span>Box</span>
              </div>
              <div class="legend-item">
                <div class="legend-box" style="background: #2ecc71"></div>
                <span>Target</span>
              </div>
              <div class="legend-item">
                <div
                  class="legend-box"
                  style="background: #74b9ff; border: 2px solid #0984e3"
                ></div>
                <span>Walk</span>
              </div>
              <div class="legend-item">
                <div
                  class="legend-box"
                  style="background: #fab1a0; border: 2px solid #e74c3c"
                ></div>
                <span>Push</span>
              </div>
            </div>
          </div>

          <div class="action-indicator">
            <div class="action-box action-walk" id="action-walk">
              üö∂ WALK (Cost 0)<br />
              <small>‚Üí Add to FRONT</small>
            </div>
            <div class="action-box action-push" id="action-push">
              üì¶ PUSH (Cost 1)<br />
              <small>‚Üí Add to BACK</small>
            </div>
          </div>

          <div class="controls">
            <button class="btn-success" onclick="stepForward()">‚ñ∂ Step</button>
            <button class="btn-primary" onclick="autoPlay()">
              ‚èµ Auto Play
            </button>
            <button class="btn-warning" onclick="pauseAuto()">‚è∏ Pause</button>
            <button class="btn-danger" onclick="resetVisualization()">
              ‚Ü∫ Reset
            </button>
          </div>

          <div class="speed-control">
            <span>Speed:</span>
            <input type="range" id="speed" min="100" max="1500" value="600" />
            <span id="speed-value">600ms</span>
          </div>

          <div id="message-box" class="message-box"></div>

          <div class="state-panel">
            <div class="state-grid">
              <div class="state-item">
                <div class="state-label">Box Position</div>
                <div class="state-value" id="box-pos">-</div>
              </div>
              <div class="state-item">
                <div class="state-label">Player Position</div>
                <div class="state-value" id="player-pos">-</div>
              </div>
              <div class="state-item">
                <div class="state-label">Current Distance (Pushes)</div>
                <div class="state-value highlight" id="current-dist">0</div>
              </div>
              <div class="state-item">
                <div class="state-label">States Processed</div>
                <div class="state-value" id="states-processed">0</div>
              </div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="section-title">
            <div class="section-icon">üìö</div>
            Deque (Double-Ended Queue)
          </div>

          <div class="deque-container">
            <div class="deque-header">
              <div class="deque-title"><span>üîÑ</span> 0-1 BFS Deque</div>
              <div class="deque-size" id="deque-size">Size: 0</div>
            </div>
            <div class="deque-labels">
              <div class="deque-label front">
                ‚óÄ FRONT (Process first, add walks here)
              </div>
              <div class="deque-label back">BACK (Add pushes here) ‚ñ∂</div>
            </div>
            <div class="deque-visual" id="deque-visual">
              <div style="color: #aaa; font-style: italic">Empty deque</div>
            </div>
            <div class="deque-explanation" id="deque-explanation">
              <strong>How 0-1 BFS works:</strong> Always process from FRONT.
              Cost-0 edges (walks) add to FRONT, cost-1 edges (pushes) add to
              BACK. This ensures we always process states in order of minimum
              cost!
            </div>
          </div>

          <div class="invariant-box">
            <div class="invariant-title">
              <span>üîí</span> Algorithm Invariant
            </div>
            <div class="invariant-text" id="invariant-text">
              At any moment, the deque contains states with at most
              <strong>2 different push counts: d and d+1</strong>. All states
              with push count <strong>d</strong> are at the front. This
              guarantees optimal ordering!
            </div>
          </div>

          <div class="explanation-box">
            <div class="explanation-title">üìù Step Explanation</div>
            <div class="explanation-text" id="explanation">
              Click <strong>Step</strong> to begin. Watch how walking adds to
              the FRONT (processed immediately) while pushing adds to the BACK
              (processed later).
            </div>
          </div>

          <div class="pseudocode">
            <span class="comment"
              >// 0-1 BFS: Optimal solution for minimum pushes</span
            >
            <span class="keyword">function</span>
            <span class="function">minPushBox</span>(grid): deque =
            [initial_state] <span class="comment">// (box, player)</span>
            dist = Map()

            <span class="keyword">while</span> deque not empty: state =
            deque.<span class="function">popFront</span>()
            <span class="comment">// Always from FRONT!</span>

            <span class="keyword">if</span> box at target:
            <span class="keyword">return</span> dist[state]

            <span class="keyword">for</span> each direction:
            <span class="keyword">if</span> player moves into box:
            <span class="push-line">
              <span class="comment">// PUSH: cost +1 ‚Üí add to BACK</span></span
            >
            <span class="push-line">
              deque.<span class="function">pushBack</span>(new_state)</span
            >
            <span class="keyword">else</span>:
            <span class="walk-line">
              <span class="comment">// WALK: cost +0 ‚Üí add to FRONT</span></span
            >
            <span class="walk-line">
              deque.<span class="function">pushFront</span>(new_state)</span
            >
          </div>

          <div class="footer-info">
            <div class="footer-title">‚ö° Optimal Complexity Analysis</div>
            <div class="complexity-grid">
              <div class="complexity-item">
                <div class="complexity-label">Time</div>
                <div class="complexity-value">O(m¬≤n¬≤)</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Space</div>
                <div class="complexity-value">O(m¬≤n¬≤)</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Guarantee</div>
                <div class="complexity-value">‚úì Min Pushes</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Grid configuration
      const gridData = [
        ["#", "#", "#", "#", "#", "#"],
        ["#", "T", "#", "#", "#", "#"],
        ["#", ".", ".", "B", ".", "#"],
        ["#", ".", "#", "#", ".", "#"],
        ["#", ".", ".", ".", "S", "#"],
        ["#", "#", "#", "#", "#", "#"],
      ];

      const ROWS = 6,
        COLS = 6;
      const DIRS = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0],
      ];
      const DIR_NAMES = ["‚Üí Right", "‚Üê Left", "‚Üì Down", "‚Üë Up"];

      let playerPos, boxPos, targetPos;
      let deque = []; // [{box: [r,c], player: [r,c], dist: n, type: 'walk'|'push'}]
      let dist = new Map();
      let statesProcessed = 0;
      let isRunning = false;
      let autoInterval = null;
      let foundSolution = false;
      let lastAction = null; // 'walk' or 'push'

      function findPositions() {
        for (let i = 0; i < ROWS; i++) {
          for (let j = 0; j < COLS; j++) {
            if (gridData[i][j] === "S") playerPos = [i, j];
            if (gridData[i][j] === "B") boxPos = [i, j];
            if (gridData[i][j] === "T") targetPos = [i, j];
          }
        }
      }

      function encodeState(br, bc, pr, pc) {
        return `${br},${bc},${pr},${pc}`;
      }

      function isValid(r, c) {
        return (
          r >= 0 && r < ROWS && c >= 0 && c < COLS && gridData[r][c] !== "#"
        );
      }

      function renderGrid(
        box,
        player,
        highlightType = null,
        highlightCell = null
      ) {
        const gridEl = document.getElementById("grid");
        gridEl.innerHTML = "";

        for (let i = 0; i < ROWS; i++) {
          for (let j = 0; j < COLS; j++) {
            const cell = document.createElement("div");
            cell.className = "cell";

            const isBox = box && box[0] === i && box[1] === j;
            const isPlayer = player && player[0] === i && player[1] === j;
            const isTarget = targetPos[0] === i && targetPos[1] === j;
            const isHighlight =
              highlightCell && highlightCell[0] === i && highlightCell[1] === j;

            if (gridData[i][j] === "#") {
              cell.classList.add("wall");
              cell.textContent = "#";
            } else if (isBox && isTarget) {
              cell.classList.add("box-on-target");
              cell.textContent = "‚òÖ";
            } else if (isBox) {
              cell.classList.add("box");
              cell.textContent = "B";
            } else if (isPlayer) {
              cell.classList.add("player");
              cell.textContent = "S";
              if (highlightType === "walk" && isHighlight) {
                cell.classList.add("walk-highlight");
              }
            } else if (isTarget) {
              cell.classList.add("target");
              cell.textContent = "T";
            } else if (isHighlight) {
              if (highlightType === "walk") {
                cell.classList.add("walk-highlight");
                cell.textContent = "üë£";
              } else if (highlightType === "push") {
                cell.classList.add("push-highlight");
                cell.textContent = "üì¶";
              }
            } else {
              cell.classList.add("floor");
              cell.textContent = "¬∑";
            }

            gridEl.appendChild(cell);
          }
        }
      }

      function renderDeque() {
        const dequeEl = document.getElementById("deque-visual");
        const dequeSizeEl = document.getElementById("deque-size");

        dequeEl.innerHTML = "";
        dequeSizeEl.textContent = `Size: ${deque.length}`;

        if (deque.length === 0) {
          dequeEl.innerHTML =
            '<div style="color: #aaa; font-style: italic;">Empty deque</div>';
          return;
        }

        const displayCount = Math.min(deque.length, 8);

        for (let i = 0; i < displayCount; i++) {
          const item = deque[i];
          const div = document.createElement("div");
          div.className = "deque-item";

          if (i === 0) div.classList.add("current");
          if (item.type === "walk") div.classList.add("walk");
          if (item.type === "push") div.classList.add("push");
          if (item.isNew === "front") div.classList.add("new-front");
          if (item.isNew === "back") div.classList.add("new-back");

          div.innerHTML = `
                    <div class="deque-item-pos">B:(${item.box[0]},${
            item.box[1]
          })</div>
                    <div class="deque-item-pos">P:(${item.player[0]},${
            item.player[1]
          })</div>
                    <div class="deque-item-cost ${
                      item.type === "walk" ? "cost-tag-0" : "cost-tag-1"
                    }">
                        ${item.type === "walk" ? "Walk" : "Push"} | d=${
            item.dist
          }
                    </div>
                `;

          dequeEl.appendChild(div);

          if (i < displayCount - 1) {
            const arrow = document.createElement("span");
            arrow.className = "deque-arrow";
            arrow.textContent = "‚Üí";
            dequeEl.appendChild(arrow);
          }
        }

        if (deque.length > 8) {
          const more = document.createElement("div");
          more.className = "deque-item";
          more.style.background = "#eee";
          more.innerHTML = `<div>+${deque.length - 8} more</div>`;
          dequeEl.appendChild(more);
        }

        // Clear isNew flags
        deque.forEach((item) => (item.isNew = null));
      }

      function updateStateInfo(box, player, currentDist) {
        document.getElementById("box-pos").textContent = box
          ? `(${box[0]}, ${box[1]})`
          : "-";
        document.getElementById("player-pos").textContent = player
          ? `(${player[0]}, ${player[1]})`
          : "-";
        document.getElementById("current-dist").textContent = currentDist;
        document.getElementById("states-processed").textContent =
          statesProcessed;
      }

      function updateActionIndicator(action) {
        document.getElementById("action-walk").classList.remove("active");
        document.getElementById("action-push").classList.remove("active");

        if (action === "walk") {
          document.getElementById("action-walk").classList.add("active");
        } else if (action === "push") {
          document.getElementById("action-push").classList.add("active");
        }
      }

      function updateExplanation(text) {
        document.getElementById("explanation").innerHTML = text;
      }

      function updateDequeExplanation(text) {
        document.getElementById("deque-explanation").innerHTML = text;
      }

      function updateInvariant(minDist, maxDist) {
        const text =
          minDist === maxDist
            ? `Current deque contains states with push count <strong>d = ${minDist}</strong> only.`
            : `Current deque contains states with push counts <strong>d = ${minDist}</strong> and <strong>d+1 = ${maxDist}</strong>. States with d=${minDist} are at the front!`;
        document.getElementById("invariant-text").innerHTML = text;
      }

      function showMessage(text, type) {
        const msgBox = document.getElementById("message-box");
        msgBox.textContent = text;
        msgBox.className = `message-box ${type}`;
      }

      function initialize() {
        findPositions();

        const initialState = {
          box: [...boxPos],
          player: [...playerPos],
          dist: 0,
          type: "start",
        };

        deque = [initialState];
        dist.clear();
        dist.set(
          encodeState(boxPos[0], boxPos[1], playerPos[0], playerPos[1]),
          0
        );
        statesProcessed = 0;
        foundSolution = false;
        lastAction = null;

        renderGrid(boxPos, playerPos);
        renderDeque();
        updateStateInfo(boxPos, playerPos, 0);
        updateActionIndicator(null);
        updateInvariant(0, 0);
        updateExplanation(`
                <strong>Initialized!</strong><br>
                Starting state: Box at <span class="code-hl">(${boxPos[0]},${boxPos[1]})</span>, 
                Player at <span class="code-hl">(${playerPos[0]},${playerPos[1]})</span><br>
                Target: <span class="code-hl">(${targetPos[0]},${targetPos[1]})</span><br><br>
                Click <strong>Step</strong> to process states using 0-1 BFS!
            `);
        updateDequeExplanation(`
                <strong>0-1 BFS Rule:</strong> Process from FRONT. Walks (cost 0) ‚Üí FRONT. Pushes (cost 1) ‚Üí BACK.
            `);
      }

      function stepForward() {
        if (foundSolution || deque.length === 0) {
          if (deque.length === 0 && !foundSolution) {
            showMessage("No solution found! Deque is empty.", "info");
          }
          return;
        }

        // Pop from front
        const current = deque.shift();
        const { box, player, dist: currentDist } = current;
        statesProcessed++;

        // Check solution
        if (box[0] === targetPos[0] && box[1] === targetPos[1]) {
          foundSolution = true;
          renderGrid(box, player);
          renderDeque();
          updateStateInfo(box, player, currentDist);
          showMessage(
            `üéâ Solution found! Minimum pushes: ${currentDist}`,
            "success"
          );
          updateExplanation(`
                    <strong>üéâ TARGET REACHED!</strong><br>
                    Box arrived at <span class="code-hl">(${targetPos[0]},${targetPos[1]})</span>!<br>
                    <strong>Minimum pushes: ${currentDist}</strong><br>
                    States processed: ${statesProcessed}<br><br>
                    The 0-1 BFS guarantees this is optimal because we always process states in order of increasing push count!
                `);
          pauseAuto();
          return;
        }

        let walksAdded = 0,
          pushesAdded = 0;
        let lastWalkPos = null,
          lastPushPos = null;

        // Try all 4 directions
        for (let d = 0; d < 4; d++) {
          const [dr, dc] = DIRS[d];
          const npr = player[0] + dr;
          const npc = player[1] + dc;

          if (!isValid(npr, npc)) continue;

          if (npr === box[0] && npc === box[1]) {
            // PUSH
            const nbr = box[0] + dr;
            const nbc = box[1] + dc;

            if (!isValid(nbr, nbc)) continue;

            const newKey = encodeState(nbr, nbc, npr, npc);
            const newDist = currentDist + 1;

            if (!dist.has(newKey) || dist.get(newKey) > newDist) {
              dist.set(newKey, newDist);
              deque.push({
                box: [nbr, nbc],
                player: [npr, npc],
                dist: newDist,
                type: "push",
                isNew: "back",
              });
              pushesAdded++;
              lastPushPos = [nbr, nbc];
            }
          } else {
            // WALK
            const newKey = encodeState(box[0], box[1], npr, npc);

            if (!dist.has(newKey) || dist.get(newKey) > currentDist) {
              dist.set(newKey, currentDist);
              deque.unshift({
                box: [...box],
                player: [npr, npc],
                dist: currentDist,
                type: "walk",
                isNew: "front",
              });
              walksAdded++;
              lastWalkPos = [npr, npc];
            }
          }
        }

        // Determine action for highlighting
        if (walksAdded > 0) {
          lastAction = "walk";
          renderGrid(box, player, "walk", lastWalkPos);
          updateActionIndicator("walk");
        } else if (pushesAdded > 0) {
          lastAction = "push";
          renderGrid(box, player, "push", lastPushPos);
          updateActionIndicator("push");
        } else {
          lastAction = null;
          renderGrid(box, player);
          updateActionIndicator(null);
        }

        renderDeque();
        updateStateInfo(box, player, currentDist);

        // Calculate invariant
        if (deque.length > 0) {
          const minD = deque[0].dist;
          const maxD = deque[deque.length - 1].dist;
          updateInvariant(minD, maxD);
        }

        updateDequeExplanation(`
                <strong>Step ${statesProcessed}:</strong> 
                Added <span style="color: #155724; font-weight: bold;">${walksAdded} walks</span> to FRONT, 
                <span style="color: #721c24; font-weight: bold;">${pushesAdded} pushes</span> to BACK.
                ${
                  walksAdded > 0
                    ? "<br>Walks added to front ‚Üí will be processed BEFORE pushes!"
                    : ""
                }
            `);

        updateExplanation(`
                <strong>Processing state:</strong> Box <span class="code-hl">(${box[0]},${box[1]})</span>, 
                Player <span class="code-hl">(${player[0]},${player[1]})</span>, Distance: ${currentDist}<br><br>
                <strong>Results:</strong><br>
                üö∂ Walks added to FRONT: <strong>${walksAdded}</strong> (cost +0, processed next!)<br>
                üì¶ Pushes added to BACK: <strong>${pushesAdded}</strong> (cost +1, processed later)<br><br>
                <em>This ordering ensures states are always processed by minimum push count!</em>
            `);
      }

      function autoPlay() {
        if (isRunning) return;
        isRunning = true;

        const speed = parseInt(document.getElementById("speed").value);
        autoInterval = setInterval(() => {
          if (foundSolution || deque.length === 0) {
            pauseAuto();
            return;
          }
          stepForward();
        }, speed);
      }

      function pauseAuto() {
        isRunning = false;
        if (autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
      }

      function resetVisualization() {
        pauseAuto();
        document.getElementById("message-box").className = "message-box";
        initialize();
      }

      document.getElementById("speed").addEventListener("input", function () {
        document.getElementById("speed-value").textContent = this.value + "ms";
        if (isRunning) {
          pauseAuto();
          autoPlay();
        }
      });

      window.onload = initialize;
    </script>
  </body>
</html>
