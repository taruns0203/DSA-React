<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Array Visualizer ‚Äî Interactive DSA Explorer</title>
<style>
/* ========== CSS VARIABLES & RESET ========== */
:root {
  --bg: #F4F1EC;
  --bg2: #FFFDF9;
  --card: #FFFFFF;
  --text: #1A1A2E;
  --text2: #5A5A7A;
  --text3: #8E8EA8;
  --accent: #6C5CE7;
  --accent2: #A29BFE;
  --accent3: #EAE6FF;
  --green: #00B894;
  --green2: #E8FAF0;
  --red: #FD7272;
  --red2: #FFF0F0;
  --orange: #FDCB6E;
  --orange2: #FFF9E6;
  --blue: #74B9FF;
  --blue2: #EBF5FF;
  --pink: #E84393;
  --teal: #00CEC9;
  --shadow-sm: 0 2px 8px rgba(108,92,231,0.06);
  --shadow-md: 0 4px 20px rgba(108,92,231,0.1);
  --shadow-lg: 0 8px 40px rgba(108,92,231,0.14);
  --shadow-glow: 0 0 20px rgba(108,92,231,0.2);
  --radius: 16px;
  --radius-sm: 10px;
  --radius-xs: 6px;
  --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --font-mono: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
  --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  min-height: 100vh;
  overflow-x: hidden;
}

/* ========== SCROLLBAR ========== */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--accent2); border-radius: 3px; }

/* ========== HEADER ========== */
.header {
  background: linear-gradient(135deg, #6C5CE7 0%, #A29BFE 50%, #74B9FF 100%);
  padding: 28px 40px;
  color: white;
  position: relative;
  overflow: hidden;
}
.header::before {
  content: '';
  position: absolute;
  top: -50%; left: -50%;
  width: 200%; height: 200%;
  background: radial-gradient(circle at 30% 50%, rgba(255,255,255,0.08) 0%, transparent 50%);
  animation: headerShimmer 15s linear infinite;
}
@keyframes headerShimmer {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
.header-content {
  position: relative;
  z-index: 1;
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 12px;
}
.header h1 {
  font-size: 1.6rem;
  font-weight: 800;
  letter-spacing: -0.5px;
  display: flex;
  align-items: center;
  gap: 12px;
}
.header h1 .icon {
  background: rgba(255,255,255,0.2);
  width: 40px; height: 40px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  backdrop-filter: blur(10px);
}
.header-badges {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.badge {
  background: rgba(255,255,255,0.18);
  backdrop-filter: blur(10px);
  padding: 5px 14px;
  border-radius: 20px;
  font-size: 0.78rem;
  font-weight: 600;
  letter-spacing: 0.3px;
  border: 1px solid rgba(255,255,255,0.15);
}

/* ========== MAIN LAYOUT ========== */
.main {
  max-width: 1400px;
  margin: 0 auto;
  padding: 24px 24px 60px;
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 24px;
}

/* ========== CARDS ========== */
.card {
  background: var(--card);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
  border: 1px solid rgba(108,92,231,0.06);
  overflow: hidden;
  transition: box-shadow var(--transition);
}
.card:hover { box-shadow: var(--shadow-md); }
.card-title {
  font-size: 0.72rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: var(--accent);
  padding: 18px 20px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}
.card-title .dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--accent);
}
.card-body { padding: 14px 20px 20px; }

/* ========== LEFT PANEL ========== */
.left-panel {
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ========== CONTROLS ========== */
.control-group { margin-bottom: 14px; }
.control-group:last-child { margin-bottom: 0; }
.control-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text2);
  margin-bottom: 6px;
  display: block;
}

select, input[type="number"], input[type="text"] {
  width: 100%;
  padding: 10px 14px;
  border: 2px solid #EDE9FE;
  border-radius: var(--radius-sm);
  font-family: var(--font);
  font-size: 0.88rem;
  color: var(--text);
  background: var(--bg2);
  transition: var(--transition);
  outline: none;
}
select:focus, input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 4px rgba(108,92,231,0.1);
}
select { cursor: pointer; appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%236C5CE7' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 14px center;
  padding-right: 36px;
}

.input-row {
  display: flex;
  gap: 8px;
}
.input-row input { flex: 1; min-width: 0; }

/* ========== BUTTONS ========== */
.btn {
  padding: 10px 18px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: var(--font);
  font-size: 0.82rem;
  font-weight: 700;
  cursor: pointer;
  transition: all var(--transition);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  letter-spacing: 0.2px;
}
.btn:active { transform: scale(0.96); }

.btn-primary {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: white;
  box-shadow: 0 4px 14px rgba(108,92,231,0.3);
}
.btn-primary:hover { box-shadow: 0 6px 20px rgba(108,92,231,0.4); transform: translateY(-1px); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

.btn-secondary {
  background: var(--accent3);
  color: var(--accent);
}
.btn-secondary:hover { background: #DDD6FE; }

.btn-success {
  background: linear-gradient(135deg, var(--green), #55EFC4);
  color: white;
  box-shadow: 0 4px 14px rgba(0,184,148,0.3);
}

.btn-danger {
  background: var(--red2);
  color: var(--red);
}
.btn-danger:hover { background: #FFE0E0; }

.btn-group {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.btn-full { width: 100%; }

/* ========== SPEED CONTROL ========== */
.speed-control {
  display: flex;
  align-items: center;
  gap: 10px;
}
.speed-control input[type="range"] {
  flex: 1;
  -webkit-appearance: none;
  height: 6px;
  border-radius: 3px;
  background: linear-gradient(90deg, var(--accent3), var(--accent2));
  outline: none;
  border: none;
  padding: 0;
}
.speed-control input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px; height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(108,92,231,0.3);
}
.speed-label {
  font-size: 0.78rem;
  font-weight: 700;
  color: var(--accent);
  min-width: 40px;
  text-align: right;
}

/* ========== RIGHT PANEL ========== */
.right-panel {
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ========== ARRAY VISUALIZATION ========== */
.viz-area {
  min-height: 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 30px 20px;
  position: relative;
}

.array-container {
  display: flex;
  align-items: flex-end;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: center;
  min-height: 120px;
  padding: 10px;
}

.array-cell {
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.cell-value {
  width: 56px;
  height: 56px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 1.05rem;
  color: white;
  position: relative;
  background: linear-gradient(145deg, var(--accent), var(--accent2));
  box-shadow: 0 4px 12px rgba(108,92,231,0.25);
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.cell-index {
  font-size: 0.68rem;
  font-weight: 700;
  color: var(--text3);
  margin-top: 6px;
  font-family: var(--font-mono);
}

/* Cell States */
.cell-value.state-default {
  background: linear-gradient(145deg, var(--accent), var(--accent2));
  box-shadow: 0 4px 12px rgba(108,92,231,0.25);
}
.cell-value.state-active {
  background: linear-gradient(145deg, #E84393, #FD79A8);
  box-shadow: 0 4px 16px rgba(232,67,147,0.4);
  transform: scale(1.15) translateY(-6px);
}
.cell-value.state-comparing {
  background: linear-gradient(145deg, #FDCB6E, #F39C12);
  box-shadow: 0 4px 16px rgba(253,203,110,0.4);
  color: #1A1A2E;
  transform: scale(1.08) translateY(-3px);
}
.cell-value.state-found {
  background: linear-gradient(145deg, var(--green), #55EFC4);
  box-shadow: 0 4px 16px rgba(0,184,148,0.4);
  transform: scale(1.18) translateY(-8px);
  animation: foundPulse 0.6s ease-in-out;
}
.cell-value.state-shifting {
  background: linear-gradient(145deg, var(--blue), #0984E3);
  box-shadow: 0 4px 16px rgba(116,185,255,0.4);
  transform: translateX(10px);
}
.cell-value.state-sorted {
  background: linear-gradient(145deg, var(--teal), #81ECEC);
  box-shadow: 0 4px 12px rgba(0,206,201,0.3);
  color: #1A1A2E;
}
.cell-value.state-removed {
  background: linear-gradient(145deg, var(--red), #E17055);
  box-shadow: 0 4px 16px rgba(253,114,114,0.4);
  opacity: 0.6;
  transform: scale(0.85) translateY(8px);
}
.cell-value.state-inserted {
  background: linear-gradient(145deg, var(--green), #55EFC4);
  box-shadow: 0 6px 20px rgba(0,184,148,0.45);
  transform: scale(1.15) translateY(-6px);
  animation: insertBounce 0.5s ease;
}
.cell-value.state-pivot {
  background: linear-gradient(145deg, #E84393, #6C5CE7);
  box-shadow: 0 4px 16px rgba(232,67,147,0.4);
  border: 3px solid white;
}
.cell-value.state-pointer-left {
  border-bottom: 4px solid var(--green);
}
.cell-value.state-pointer-right {
  border-bottom: 4px solid var(--red);
}

@keyframes foundPulse {
  0%, 100% { transform: scale(1.18) translateY(-8px); }
  50% { transform: scale(1.25) translateY(-12px); }
}
@keyframes insertBounce {
  0% { transform: scale(0) translateY(30px); opacity: 0; }
  60% { transform: scale(1.25) translateY(-10px); }
  100% { transform: scale(1.15) translateY(-6px); opacity: 1; }
}
@keyframes cellAppear {
  0% { transform: scale(0) rotate(-10deg); opacity: 0; }
  100% { transform: scale(1) rotate(0); opacity: 1; }
}

/* Pointer Labels */
.pointer-label {
  position: absolute;
  top: -22px;
  font-size: 0.65rem;
  font-weight: 800;
  padding: 2px 7px;
  border-radius: 6px;
  color: white;
  letter-spacing: 0.5px;
  white-space: nowrap;
}
.pointer-label.ptr-i { background: var(--pink); }
.pointer-label.ptr-j { background: var(--green); }
.pointer-label.ptr-mid { background: var(--orange); color: var(--text); }
.pointer-label.ptr-lo { background: var(--teal); }
.pointer-label.ptr-hi { background: var(--red); }

/* Empty State */
.empty-state {
  text-align: center;
  padding: 30px;
  color: var(--text3);
}
.empty-state .empty-icon {
  font-size: 3rem;
  margin-bottom: 10px;
  opacity: 0.4;
}
.empty-state p { font-size: 0.9rem; }

/* ========== LOG PANEL ========== */
.log-panel {
  max-height: 180px;
  overflow-y: auto;
  font-family: var(--font-mono);
  font-size: 0.78rem;
  padding: 14px 20px;
  background: #FAFAFE;
  border-top: 1px solid #F0EDFA;
}
.log-entry {
  padding: 5px 0;
  border-bottom: 1px solid #F5F3FF;
  display: flex;
  gap: 8px;
  align-items: flex-start;
  animation: logSlide 0.3s ease;
}
@keyframes logSlide {
  from { opacity: 0; transform: translateX(-10px); }
}
.log-step {
  background: var(--accent3);
  color: var(--accent);
  padding: 1px 8px;
  border-radius: 4px;
  font-weight: 700;
  font-size: 0.68rem;
  white-space: nowrap;
}
.log-text { color: var(--text2); line-height: 1.5; }
.log-text strong { color: var(--text); }

/* ========== COMPLEXITY BADGE ========== */
.complexity-display {
  display: flex;
  gap: 12px;
  padding: 14px 20px;
  background: linear-gradient(135deg, #FAFAFE, #F5F0FF);
  border-top: 1px solid #F0EDFA;
  flex-wrap: wrap;
}
.complexity-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.78rem;
}
.complexity-chip .label {
  font-weight: 600;
  color: var(--text3);
}
.complexity-chip .value {
  font-family: var(--font-mono);
  font-weight: 800;
  padding: 3px 10px;
  border-radius: 6px;
  font-size: 0.75rem;
}
.complexity-chip .value.time {
  background: var(--accent3);
  color: var(--accent);
}
.complexity-chip .value.space {
  background: var(--green2);
  color: var(--green);
}

/* ========== LEGEND ========== */
.legend {
  display: flex;
  gap: 14px;
  flex-wrap: wrap;
  padding: 14px 20px;
  border-top: 1px solid #F0EDFA;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.72rem;
  color: var(--text2);
  font-weight: 600;
}
.legend-dot {
  width: 14px; height: 14px;
  border-radius: 5px;
  flex-shrink: 0;
}
.legend-dot.l-default { background: linear-gradient(145deg, var(--accent), var(--accent2)); }
.legend-dot.l-active { background: linear-gradient(145deg, #E84393, #FD79A8); }
.legend-dot.l-comparing { background: linear-gradient(145deg, #FDCB6E, #F39C12); }
.legend-dot.l-found { background: linear-gradient(145deg, var(--green), #55EFC4); }
.legend-dot.l-shifting { background: linear-gradient(145deg, var(--blue), #0984E3); }
.legend-dot.l-removed { background: linear-gradient(145deg, var(--red), #E17055); }

/* ========== EXPLANATION PANEL ========== */
.explanation-text {
  font-size: 0.88rem;
  line-height: 1.7;
  color: var(--text2);
  min-height: 40px;
}
.explanation-text .highlight {
  background: var(--accent3);
  color: var(--accent);
  padding: 1px 7px;
  border-radius: 4px;
  font-weight: 700;
  font-family: var(--font-mono);
  font-size: 0.82rem;
}

/* ========== EDUCATIONAL PANEL ========== */
.edu-tabs {
  display: flex;
  border-bottom: 2px solid #F0EDFA;
}
.edu-tab {
  padding: 12px 18px;
  font-size: 0.78rem;
  font-weight: 700;
  color: var(--text3);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  margin-bottom: -2px;
  transition: var(--transition);
}
.edu-tab:hover { color: var(--accent); }
.edu-tab.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}
.edu-content {
  padding: 18px 20px;
  font-size: 0.84rem;
  line-height: 1.7;
  color: var(--text2);
  display: none;
}
.edu-content.active { display: block; }
.edu-content h4 {
  color: var(--text);
  font-size: 0.9rem;
  margin: 12px 0 4px;
}
.edu-content h4:first-child { margin-top: 0; }
.edu-content code {
  background: var(--accent3);
  padding: 1px 6px;
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.8rem;
  color: var(--accent);
}
.edu-table {
  width: 100%;
  border-collapse: collapse;
  margin: 8px 0;
  font-size: 0.8rem;
}
.edu-table th, .edu-table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #F0EDFA;
}
.edu-table th {
  font-weight: 700;
  color: var(--accent);
  background: var(--accent3);
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.edu-table td { font-family: var(--font-mono); }
.edge-case {
  background: var(--orange2);
  border-left: 3px solid var(--orange);
  padding: 8px 12px;
  border-radius: 0 8px 8px 0;
  margin: 6px 0;
  font-size: 0.82rem;
}

/* ========== MEMORY VIEW ========== */
.memory-bar {
  display: flex;
  gap: 2px;
  margin: 10px 0;
  padding: 8px;
  background: #FAFAFE;
  border-radius: 10px;
  border: 1px solid #F0EDFA;
  overflow-x: auto;
}
.mem-slot {
  min-width: 40px;
  height: 28px;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.65rem;
  font-weight: 700;
  font-family: var(--font-mono);
  transition: all 0.3s ease;
  flex-shrink: 0;
}
.mem-slot.used {
  background: linear-gradient(145deg, var(--accent3), #DDD6FE);
  color: var(--accent);
}
.mem-slot.empty {
  background: #F5F5F5;
  color: #CCC;
}
.mem-info {
  font-size: 0.72rem;
  color: var(--text3);
  display: flex;
  justify-content: space-between;
}

/* ========== STATUS BAR ========== */
.status-bar {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 20px;
  background: linear-gradient(135deg, #FAFAFE, #F0EDFA);
  border-top: 1px solid #F0EDFA;
  font-size: 0.78rem;
}
.status-dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  background: var(--green);
  animation: statusPulse 2s infinite;
}
.status-dot.busy {
  background: var(--orange);
}
@keyframes statusPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}
.status-text { color: var(--text2); font-weight: 600; }

/* ========== RESPONSIVE ========== */
@media (max-width: 900px) {
  .main {
    grid-template-columns: 1fr;
  }
  .header { padding: 20px; }
  .header h1 { font-size: 1.3rem; }
}
@media (max-width: 600px) {
  .main { padding: 12px; gap: 12px; }
  .cell-value { width: 44px; height: 44px; font-size: 0.88rem; border-radius: 10px; }
  .btn { padding: 8px 14px; font-size: 0.78rem; }
}
</style>
</head>
<body>

<!-- ========== HEADER ========== -->
<header class="header">
  <div class="header-content">
    <h1>
      <span class="icon">‚ü¶‚üß</span>
      Array Visualizer
    </h1>
    <div class="header-badges">
      <span class="badge">O(1) Access</span>
      <span class="badge">Contiguous Memory</span>
      <span class="badge">FAANG Ready</span>
    </div>
  </div>
</header>

<!-- ========== MAIN ========== -->
<div class="main">

  <!-- LEFT PANEL: Controls -->
  <div class="left-panel">

    <!-- Operation Selector -->
    <div class="card">
      <div class="card-title"><span class="dot"></span>Operation</div>
      <div class="card-body">
        <div class="control-group">
          <label class="control-label">Select Operation</label>
          <select id="operationSelect" onchange="onOperationChange()">
            <option value="insert_end">Push (Insert at End)</option>
            <option value="insert_at">Insert at Index</option>
            <option value="delete_end">Pop (Delete from End)</option>
            <option value="delete_at">Delete at Index</option>
            <option value="access">Access by Index</option>
            <option value="update">Update at Index</option>
            <option value="linear_search">Linear Search</option>
            <option value="binary_search">Binary Search (sorted)</option>
            <option value="reverse">Reverse Array</option>
            <option value="find_min_max">Find Min / Max</option>
          </select>
        </div>

        <div class="control-group" id="inputGroup">
          <label class="control-label" id="inputLabel">Value</label>
          <div class="input-row">
            <input type="number" id="inputValue" placeholder="Value" />
            <input type="number" id="inputIndex" placeholder="Index" style="display:none;" />
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary btn-full" id="executeBtn" onclick="execute()">
            ‚ñ∂ Execute
          </button>
        </div>
        <div class="btn-group" style="margin-top:8px;">
          <button class="btn btn-secondary" id="stepBtn" onclick="stepThrough()" title="Step through one step at a time">
            ‚è≠ Step
          </button>
          <button class="btn btn-success" id="autoBtn" onclick="toggleAutoPlay()">
            ‚èØ Auto
          </button>
          <button class="btn btn-danger" onclick="resetViz()">
            ‚Ü∫ Reset
          </button>
        </div>
      </div>
    </div>

    <!-- Array Setup -->
    <div class="card">
      <div class="card-title"><span class="dot"></span>Array Setup</div>
      <div class="card-body">
        <div class="control-group">
          <label class="control-label">Initialize Array (comma-separated)</label>
          <input type="text" id="initInput" placeholder="e.g. 5, 12, 3, 8, 21, 7" />
        </div>
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="initFromInput()">Load</button>
          <button class="btn btn-secondary" onclick="generateRandom()">üé≤ Random</button>
          <button class="btn btn-secondary" onclick="generateSorted()">üìà Sorted</button>
          <button class="btn btn-danger" onclick="clearArray()">Clear</button>
        </div>
      </div>
    </div>

    <!-- Speed Control -->
    <div class="card">
      <div class="card-title"><span class="dot"></span>Animation Speed</div>
      <div class="card-body">
        <div class="speed-control">
          <span style="font-size:0.82rem;">üê¢</span>
          <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="updateSpeed()" />
          <span style="font-size:0.82rem;">üêá</span>
          <span class="speed-label" id="speedLabel">5x</span>
        </div>
      </div>
    </div>

    <!-- Legend -->
    <div class="card">
      <div class="card-title"><span class="dot"></span>Color Legend</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot l-default"></div>Default</div>
        <div class="legend-item"><div class="legend-dot l-active"></div>Active / Current</div>
        <div class="legend-item"><div class="legend-dot l-comparing"></div>Comparing</div>
        <div class="legend-item"><div class="legend-dot l-found"></div>Found / Inserted</div>
        <div class="legend-item"><div class="legend-dot l-shifting"></div>Shifting</div>
        <div class="legend-item"><div class="legend-dot l-removed"></div>Removed</div>
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL: Visualization + Education -->
  <div class="right-panel">

    <!-- Visualization -->
    <div class="card" style="flex-shrink:0;">
      <div class="card-title"><span class="dot"></span>Visualization</div>
      <div class="viz-area" id="vizArea">
        <div class="array-container" id="arrayContainer"></div>
      </div>
      <!-- Memory bar -->
      <div style="padding:0 20px;">
        <div class="mem-info">
          <span>Memory Layout (capacity: <strong id="capDisplay">16</strong>)</span>
          <span>Length: <strong id="lenDisplay">0</strong></span>
        </div>
        <div class="memory-bar" id="memoryBar"></div>
      </div>
      <!-- Complexity -->
      <div class="complexity-display">
        <div class="complexity-chip">
          <span class="label">Time:</span>
          <span class="value time" id="timeComplexity">O(1)</span>
        </div>
        <div class="complexity-chip">
          <span class="label">Space:</span>
          <span class="value space" id="spaceComplexity">O(1)</span>
        </div>
        <div class="complexity-chip">
          <span class="label">Operation:</span>
          <span class="value time" id="opName" style="background:#FFF0F0;color:#E84393;">‚Äî</span>
        </div>
      </div>
      <!-- Status bar -->
      <div class="status-bar">
        <div class="status-dot" id="statusDot"></div>
        <span class="status-text" id="statusText">Ready</span>
      </div>
    </div>

    <!-- Explanation -->
    <div class="card">
      <div class="card-title"><span class="dot"></span>Step Explanation</div>
      <div class="card-body">
        <div class="explanation-text" id="explanationText">
          Select an operation and click <strong>Execute</strong> or <strong>Step</strong> to begin. The visualizer will animate each step and explain what's happening internally.
        </div>
      </div>
      <div class="log-panel" id="logPanel"></div>
    </div>

    <!-- Educational Panel -->
    <div class="card">
      <div class="edu-tabs" id="eduTabs">
        <div class="edu-tab active" data-tab="intuition" onclick="switchEduTab('intuition')">Intuition</div>
        <div class="edu-tab" data-tab="operations" onclick="switchEduTab('operations')">Operations</div>
        <div class="edu-tab" data-tab="complexity" onclick="switchEduTab('complexity')">Complexity</div>
        <div class="edu-tab" data-tab="edge" onclick="switchEduTab('edge')">Edge Cases</div>
      </div>
      <div class="edu-content active" id="edu-intuition">
        <h4>What is an Array?</h4>
        A contiguous block of memory storing elements of the same type sequentially. The key power is <strong>O(1) random access</strong> ‚Äî given an index, you can instantly compute the memory address: <code>base + index √ó size</code>.
        <h4>Why use Arrays?</h4>
        Arrays are the most cache-friendly data structure because elements sit next to each other in memory. This makes traversal blazingly fast on modern hardware. They are the building block of stacks, heaps, hash tables, and more.
        <h4>Real-World Analogy</h4>
        Numbered lockers in a hallway ‚Äî go directly to any locker by number without checking others. All lockers are the same size, and the row has a fixed length.
      </div>
      <div class="edu-content" id="edu-operations">
        <h4>Core Operations</h4>
        <strong>Access / Update:</strong> O(1) ‚Äî address arithmetic. The fundamental advantage of arrays.<br>
        <strong>Push (end):</strong> Amortized O(1) ‚Äî append at length index. When capacity is full, the dynamic array doubles its size and copies all elements (O(n) worst case).<br>
        <strong>Insert at index:</strong> O(n) ‚Äî must shift all elements after the index one position right to make room.<br>
        <strong>Delete at index:</strong> O(n) ‚Äî must shift all elements after the deleted index one position left.<br>
        <strong>Search:</strong> O(n) linear for unsorted, O(log n) binary search for sorted arrays.<br>
        <strong>Reverse:</strong> O(n) ‚Äî two-pointer swap from both ends.
      </div>
      <div class="edu-content" id="edu-complexity">
        <table class="edu-table">
          <thead>
            <tr><th>Operation</th><th>Best</th><th>Average</th><th>Worst</th></tr>
          </thead>
          <tbody>
            <tr><td>Access</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
            <tr><td>Search</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr>
            <tr><td>Binary Search</td><td>O(1)</td><td>O(log n)</td><td>O(log n)</td></tr>
            <tr><td>Push</td><td>O(1)</td><td>O(1)*</td><td>O(n)‚Ä†</td></tr>
            <tr><td>Insert</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr>
            <tr><td>Delete</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr>
            <tr><td>Reverse</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr>
          </tbody>
        </table>
        <p style="font-size:0.75rem;color:var(--text3);margin-top:6px;">* Amortized &nbsp; ‚Ä† When resize is triggered</p>
      </div>
      <div class="edu-content" id="edu-edge">
        <div class="edge-case">‚ö†Ô∏è <strong>Empty Array:</strong> Accessing, deleting, or popping from an empty array. Always check <code>length === 0</code> first.</div>
        <div class="edge-case">‚ö†Ô∏è <strong>Out of Bounds:</strong> Index &lt; 0 or index &ge; length. The #1 source of runtime errors.</div>
        <div class="edge-case">‚ö†Ô∏è <strong>Single Element:</strong> Reverse, search, and min/max on a 1-element array. Ensure loops handle this.</div>
        <div class="edge-case">‚ö†Ô∏è <strong>Duplicates:</strong> Search may return first occurrence only. Binary search needs variants for first/last.</div>
        <div class="edge-case">‚ö†Ô∏è <strong>Integer Overflow:</strong> <code>(lo + hi) / 2</code> can overflow. Use <code>lo + (hi - lo) / 2</code>.</div>
        <div class="edge-case">‚ö†Ô∏è <strong>Unsorted Binary Search:</strong> Applying binary search on unsorted data gives wrong results.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   ARRAY VISUALIZER ‚Äî CORE ENGINE
   ============================================================ */

// --- STATE ---
let arr = [];
let capacity = 16;
let animSpeed = 400; // ms per step
let steps = [];       // queued animation steps
let stepIndex = 0;
let isPlaying = false;
let autoInterval = null;
let isBusy = false;

// --- INIT ---
window.addEventListener('DOMContentLoaded', () => {
  generateRandom();
  onOperationChange();
});

// --- ARRAY MANAGEMENT ---
function generateRandom() {
  const len = 6 + Math.floor(Math.random() * 5);
  arr = Array.from({ length: len }, () => Math.floor(Math.random() * 99) + 1);
  capacity = Math.max(16, nextPow2(arr.length));
  resetUI();
  renderArray();
}

function generateSorted() {
  const len = 6 + Math.floor(Math.random() * 5);
  arr = Array.from({ length: len }, () => Math.floor(Math.random() * 99) + 1).sort((a, b) => a - b);
  capacity = Math.max(16, nextPow2(arr.length));
  resetUI();
  renderArray();
}

function initFromInput() {
  const raw = document.getElementById('initInput').value;
  const parsed = raw.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
  if (parsed.length === 0) return;
  arr = parsed;
  capacity = Math.max(16, nextPow2(arr.length));
  resetUI();
  renderArray();
}

function clearArray() {
  arr = [];
  capacity = 16;
  resetUI();
  renderArray();
}

function nextPow2(n) {
  let p = 1;
  while (p < n) p *= 2;
  return p;
}

// --- UI RENDERING ---
function renderArray(cellStates = {}, pointers = {}) {
  const container = document.getElementById('arrayContainer');
  if (arr.length === 0) {
    container.innerHTML = `<div class="empty-state"><div class="empty-icon">[ ]</div><p>Array is empty. Generate or load data to begin.</p></div>`;
  } else {
    container.innerHTML = arr.map((val, i) => {
      const state = cellStates[i] || 'default';
      const ptrLabels = [];
      for (const [key, idx] of Object.entries(pointers)) {
        if (idx === i) ptrLabels.push(key);
      }
      const ptrHTML = ptrLabels.map(p => {
        const cls = p === 'i' ? 'ptr-i' : p === 'j' ? 'ptr-j' : p === 'mid' ? 'ptr-mid' : p === 'lo' ? 'ptr-lo' : p === 'hi' ? 'ptr-hi' : 'ptr-i';
        return `<span class="pointer-label ${cls}">${p}</span>`;
      }).join('');
      return `<div class="array-cell" style="animation: cellAppear 0.3s ease ${i * 0.03}s both;">
        <div class="cell-value state-${state}" style="position:relative;">
          ${ptrHTML}
          ${val}
        </div>
        <div class="cell-index">${i}</div>
      </div>`;
    }).join('');
  }
  renderMemoryBar();
  document.getElementById('lenDisplay').textContent = arr.length;
  document.getElementById('capDisplay').textContent = capacity;
}

function renderMemoryBar() {
  const bar = document.getElementById('memoryBar');
  let html = '';
  for (let i = 0; i < Math.min(capacity, 32); i++) {
    if (i < arr.length) {
      html += `<div class="mem-slot used">${arr[i]}</div>`;
    } else {
      html += `<div class="mem-slot empty">‚Äî</div>`;
    }
  }
  if (capacity > 32) html += `<div class="mem-slot empty" style="min-width:50px;">‚Ä¶+${capacity - 32}</div>`;
  bar.innerHTML = html;
}

// --- OPERATION INPUT CONFIG ---
function onOperationChange() {
  const op = document.getElementById('operationSelect').value;
  const valInput = document.getElementById('inputValue');
  const idxInput = document.getElementById('inputIndex');
  const label = document.getElementById('inputLabel');

  valInput.style.display = 'block';
  idxInput.style.display = 'none';
  label.textContent = 'Value';
  valInput.placeholder = 'Value';

  switch (op) {
    case 'insert_end':
      label.textContent = 'Value to push';
      valInput.placeholder = 'e.g. 42';
      break;
    case 'insert_at':
      label.textContent = 'Value & Index';
      valInput.placeholder = 'Value';
      idxInput.style.display = 'block';
      idxInput.placeholder = 'Index';
      break;
    case 'delete_end':
      valInput.style.display = 'none';
      label.textContent = 'No input needed';
      break;
    case 'delete_at':
      label.textContent = 'Index to delete';
      valInput.placeholder = 'Index';
      break;
    case 'access':
      label.textContent = 'Index to access';
      valInput.placeholder = 'Index';
      break;
    case 'update':
      label.textContent = 'Index & New Value';
      valInput.placeholder = 'Index';
      idxInput.style.display = 'block';
      idxInput.placeholder = 'New value';
      break;
    case 'linear_search':
      label.textContent = 'Value to search';
      valInput.placeholder = 'Target value';
      break;
    case 'binary_search':
      label.textContent = 'Value to search (sorted)';
      valInput.placeholder = 'Target value';
      break;
    case 'reverse':
    case 'find_min_max':
      valInput.style.display = 'none';
      label.textContent = 'No input needed';
      break;
  }
}

// --- SPEED ---
function updateSpeed() {
  const val = parseInt(document.getElementById('speedSlider').value);
  document.getElementById('speedLabel').textContent = val + 'x';
  animSpeed = 900 - (val - 1) * 85; // range ~ 900ms to 135ms
}

// --- RESET UI ---
function resetUI() {
  stopAutoPlay();
  steps = [];
  stepIndex = 0;
  isBusy = false;
  document.getElementById('logPanel').innerHTML = '';
  document.getElementById('explanationText').innerHTML = 'Select an operation and click <strong>Execute</strong> or <strong>Step</strong> to begin.';
  setStatus('Ready', false);
}

// --- STATUS ---
function setStatus(text, busy) {
  document.getElementById('statusText').textContent = text;
  const dot = document.getElementById('statusDot');
  busy ? dot.classList.add('busy') : dot.classList.remove('busy');
}

function setComplexity(time, space, opName) {
  document.getElementById('timeComplexity').textContent = time;
  document.getElementById('spaceComplexity').textContent = space;
  document.getElementById('opName').textContent = opName;
}

function addLog(step, text) {
  const panel = document.getElementById('logPanel');
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.innerHTML = `<span class="log-step">${step}</span><span class="log-text">${text}</span>`;
  panel.prepend(entry);
}

function explain(html) {
  document.getElementById('explanationText').innerHTML = html;
}

// --- EDU TABS ---
function switchEduTab(tab) {
  document.querySelectorAll('.edu-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.edu-content').forEach(c => c.classList.remove('active'));
  document.querySelector(`.edu-tab[data-tab="${tab}"]`).classList.add('active');
  document.getElementById('edu-' + tab).classList.add('active');
}

/* ============================================================
   STEP GENERATION ‚Äî Each operation builds a step queue
   ============================================================ */

function buildSteps() {
  const op = document.getElementById('operationSelect').value;
  const val = parseInt(document.getElementById('inputValue').value);
  const idx = parseInt(document.getElementById('inputIndex').value);
  steps = [];
  stepIndex = 0;

  switch (op) {
    case 'insert_end': buildInsertEnd(val); break;
    case 'insert_at': buildInsertAt(val, idx); break;
    case 'delete_end': buildDeleteEnd(); break;
    case 'delete_at': buildDeleteAt(val); break;
    case 'access': buildAccess(val); break;
    case 'update': buildUpdate(val, idx); break;
    case 'linear_search': buildLinearSearch(val); break;
    case 'binary_search': buildBinarySearch(val); break;
    case 'reverse': buildReverse(); break;
    case 'find_min_max': buildFindMinMax(); break;
  }
}

// Helper: push a step
function addStep(arrSnapshot, cellStates, pointers, logStep, logText, explanationHTML) {
  steps.push({
    arr: [...arrSnapshot],
    cellStates: { ...cellStates },
    pointers: { ...pointers },
    logStep, logText, explanationHTML
  });
}

// ---------- INSERT END (PUSH) ----------
function buildInsertEnd(val) {
  if (isNaN(val)) { explain('‚ö†Ô∏è Please enter a valid number.'); return; }
  setComplexity('O(1) amortized', 'O(1)', 'Push');

  // Step 1: highlight current state
  const states = {};
  addStep(arr, states, {},
    'INIT', `Array has ${arr.length} elements, capacity ${capacity}.`,
    `Pushing <span class="highlight">${val}</span> to the end. Current length: <span class="highlight">${arr.length}</span>, capacity: <span class="highlight">${capacity}</span>.`
  );

  // Check if resize needed
  if (arr.length >= capacity) {
    const oldCap = capacity;
    capacity *= 2;
    addStep(arr, {}, {},
      'RESIZE', `Capacity full! Doubling from ${oldCap} to ${capacity}.`,
      `‚ö†Ô∏è Array is full. Allocating new block of size <span class="highlight">${capacity}</span>, copying all ${arr.length} elements. This single resize is O(n), but amortized over all pushes it's O(1).`
    );
  }

  // Step 2: insert
  arr.push(val);
  const endStates = {};
  endStates[arr.length - 1] = 'inserted';
  addStep(arr, endStates, { i: arr.length - 1 },
    'INSERT', `Placed ${val} at index ${arr.length - 1}.`,
    `Wrote <span class="highlight">${val}</span> at index <span class="highlight">${arr.length - 1}</span>. Length is now <span class="highlight">${arr.length}</span>. Direct address computation ‚Äî O(1).`
  );

  // Step 3: done
  addStep(arr, {}, {},
    'DONE', 'Push complete.',
    `‚úÖ Push complete. The element <span class="highlight">${val}</span> is now at the end of the array.`
  );
}

// ---------- INSERT AT INDEX ----------
function buildInsertAt(val, idx) {
  if (isNaN(val) || isNaN(idx)) { explain('‚ö†Ô∏è Enter both a value and an index.'); return; }
  if (idx < 0 || idx > arr.length) { explain(`‚ö†Ô∏è Index <span class="highlight">${idx}</span> is out of bounds [0, ${arr.length}].`); return; }
  setComplexity('O(n)', 'O(1)', 'Insert at Index');

  addStep(arr, { [idx]: 'active' }, { i: idx },
    'INIT', `Inserting ${val} at index ${idx}. Need to shift elements right.`,
    `Inserting <span class="highlight">${val}</span> at index <span class="highlight">${idx}</span>. Must shift elements [${idx}..${arr.length - 1}] one position right.`
  );

  // Shift elements right, from end to idx
  for (let i = arr.length - 1; i >= idx; i--) {
    const states = {};
    states[i] = 'shifting';
    if (i + 1 <= arr.length) states[i + 1] = 'shifting';
    addStep(arr, states, { i: i },
      'SHIFT', `Shifting arr[${i}] = ${arr[i]} ‚Üí arr[${i + 1}].`,
      `Moving element <span class="highlight">${arr[i]}</span> from index <span class="highlight">${i}</span> to <span class="highlight">${i + 1}</span>.`
    );
  }

  // Perform the actual insert
  arr.splice(idx, 0, val);

  const insertStates = {};
  insertStates[idx] = 'inserted';
  addStep(arr, insertStates, { i: idx },
    'PLACE', `Placed ${val} at index ${idx}.`,
    `Wrote <span class="highlight">${val}</span> at index <span class="highlight">${idx}</span>. All subsequent elements have been shifted right.`
  );

  addStep(arr, {}, {},
    'DONE', `Insert complete. Length: ${arr.length}.`,
    `‚úÖ Insertion complete. Shifted <span class="highlight">${arr.length - 1 - idx}</span> elements. This is why mid-array insertion is O(n).`
  );
}

// ---------- DELETE END (POP) ----------
function buildDeleteEnd() {
  if (arr.length === 0) { explain('‚ö†Ô∏è Array is empty ‚Äî nothing to pop.'); return; }
  setComplexity('O(1)', 'O(1)', 'Pop');

  const removed = arr[arr.length - 1];
  addStep(arr, { [arr.length - 1]: 'removed' }, { i: arr.length - 1 },
    'TARGET', `Removing last element: ${removed} at index ${arr.length - 1}.`,
    `Removing last element <span class="highlight">${removed}</span> at index <span class="highlight">${arr.length - 1}</span>. No shifting needed ‚Äî O(1).`
  );

  arr.pop();
  addStep(arr, {}, {},
    'DONE', `Pop complete. Removed ${removed}. Length: ${arr.length}.`,
    `‚úÖ Popped <span class="highlight">${removed}</span>. Length is now <span class="highlight">${arr.length}</span>. This is always O(1) ‚Äî just decrement the length counter.`
  );
}

// ---------- DELETE AT INDEX ----------
function buildDeleteAt(idx) {
  if (isNaN(idx)) { explain('‚ö†Ô∏è Enter a valid index.'); return; }
  if (idx < 0 || idx >= arr.length) { explain(`‚ö†Ô∏è Index <span class="highlight">${idx}</span> out of bounds [0, ${arr.length - 1}].`); return; }
  setComplexity('O(n)', 'O(1)', 'Delete at Index');

  const removed = arr[idx];
  addStep(arr, { [idx]: 'removed' }, { i: idx },
    'TARGET', `Deleting arr[${idx}] = ${removed}. Will shift elements left.`,
    `Deleting <span class="highlight">${removed}</span> at index <span class="highlight">${idx}</span>. Must shift elements [${idx + 1}..${arr.length - 1}] one position left.`
  );

  // Show shifting
  for (let i = idx + 1; i < arr.length; i++) {
    const states = {};
    states[i] = 'shifting';
    states[i - 1] = 'shifting';
    addStep(arr, states, { i: i },
      'SHIFT', `Shifting arr[${i}] = ${arr[i]} ‚Üí arr[${i - 1}].`,
      `Moving element <span class="highlight">${arr[i]}</span> from index <span class="highlight">${i}</span> to <span class="highlight">${i - 1}</span>.`
    );
  }

  arr.splice(idx, 1);
  addStep(arr, {}, {},
    'DONE', `Deleted ${removed}. Length: ${arr.length}.`,
    `‚úÖ Deleted <span class="highlight">${removed}</span>. Shifted <span class="highlight">${arr.length - idx}</span> elements left. This is O(n) in the worst case (deleting from index 0).`
  );
}

// ---------- ACCESS ----------
function buildAccess(idx) {
  if (isNaN(idx)) { explain('‚ö†Ô∏è Enter a valid index.'); return; }
  if (idx < 0 || idx >= arr.length) { explain(`‚ö†Ô∏è Index <span class="highlight">${idx}</span> out of bounds [0, ${arr.length - 1}].`); return; }
  setComplexity('O(1)', 'O(1)', 'Access');

  addStep(arr, {}, {},
    'INIT', `Accessing index ${idx}. Computing address...`,
    `Computing address: <span class="highlight">base + ${idx} √ó elementSize</span>. This is pure arithmetic ‚Äî O(1).`
  );

  addStep(arr, { [idx]: 'found' }, { i: idx },
    'FOUND', `arr[${idx}] = ${arr[idx]}.`,
    `‚úÖ Found <span class="highlight">${arr[idx]}</span> at index <span class="highlight">${idx}</span>. Direct memory address computation ‚Äî no iteration needed. This is the superpower of arrays.`
  );
}

// ---------- UPDATE ----------
function buildUpdate(idx, newVal) {
  if (isNaN(idx) || isNaN(newVal)) { explain('‚ö†Ô∏è Enter both an index and a new value.'); return; }
  if (idx < 0 || idx >= arr.length) { explain(`‚ö†Ô∏è Index <span class="highlight">${idx}</span> out of bounds.`); return; }
  setComplexity('O(1)', 'O(1)', 'Update');

  const oldVal = arr[idx];
  addStep(arr, { [idx]: 'comparing' }, { i: idx },
    'TARGET', `Updating arr[${idx}] from ${oldVal} to ${newVal}.`,
    `Targeting index <span class="highlight">${idx}</span>. Current value: <span class="highlight">${oldVal}</span>. Will overwrite with <span class="highlight">${newVal}</span>.`
  );

  arr[idx] = newVal;
  addStep(arr, { [idx]: 'found' }, { i: idx },
    'DONE', `Updated arr[${idx}] = ${newVal} (was ${oldVal}).`,
    `‚úÖ Updated index <span class="highlight">${idx}</span> to <span class="highlight">${newVal}</span>. Same O(1) address computation as access.`
  );
}

// ---------- LINEAR SEARCH ----------
function buildLinearSearch(target) {
  if (isNaN(target)) { explain('‚ö†Ô∏è Enter a valid target value.'); return; }
  setComplexity('O(n)', 'O(1)', 'Linear Search');

  addStep(arr, {}, {},
    'INIT', `Searching for ${target}. Scanning left to right...`,
    `Linear search for <span class="highlight">${target}</span>. Will check every element from index 0 to ${arr.length - 1}.`
  );

  let found = false;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      addStep(arr, { [i]: 'found' }, { i: i },
        `CMP[${i}]`, `arr[${i}] = ${arr[i]} === ${target} ‚úì FOUND!`,
        `üéØ Found <span class="highlight">${target}</span> at index <span class="highlight">${i}</span>! Checked <span class="highlight">${i + 1}</span> element(s).`
      );
      found = true;
      break;
    } else {
      addStep(arr, { [i]: 'comparing' }, { i: i },
        `CMP[${i}]`, `arr[${i}] = ${arr[i]} ‚â† ${target}. Continue.`,
        `Comparing arr[<span class="highlight">${i}</span>] = <span class="highlight">${arr[i]}</span> with target <span class="highlight">${target}</span>. Not a match ‚Äî move to next.`
      );
    }
  }

  if (!found) {
    addStep(arr, {}, {},
      'DONE', `${target} not found in array.`,
      `‚ùå <span class="highlight">${target}</span> not found after scanning all <span class="highlight">${arr.length}</span> elements. Worst case: O(n).`
    );
  }
}

// ---------- BINARY SEARCH ----------
function buildBinarySearch(target) {
  if (isNaN(target)) { explain('‚ö†Ô∏è Enter a valid target value.'); return; }
  // Sort array for binary search
  arr.sort((a, b) => a - b);
  setComplexity('O(log n)', 'O(1)', 'Binary Search');

  addStep(arr, {}, {},
    'INIT', `Binary search for ${target}. Array must be sorted.`,
    `Binary search for <span class="highlight">${target}</span>. Array is sorted. We halve the search space each step ‚Üí O(log n).`
  );

  let lo = 0, hi = arr.length - 1;
  let iteration = 1;
  let found = false;

  while (lo <= hi) {
    const mid = lo + Math.floor((hi - lo) / 2);
    const states = {};
    states[mid] = 'comparing';
    for (let i = lo; i <= hi; i++) {
      if (i !== mid) states[i] = states[i] || 'active';
    }

    if (arr[mid] === target) {
      states[mid] = 'found';
      addStep(arr, states, { lo: lo, mid: mid, hi: hi },
        `ITER ${iteration}`, `mid=${mid}, arr[${mid}]=${arr[mid]} === ${target} ‚úì`,
        `üéØ Found! <span class="highlight">arr[${mid}] = ${arr[mid]}</span> matches target. Binary search completed in <span class="highlight">${iteration}</span> iteration(s). log‚ÇÇ(${arr.length}) ‚âà ${Math.ceil(Math.log2(arr.length))}.`
      );
      found = true;
      break;
    } else if (arr[mid] < target) {
      addStep(arr, states, { lo: lo, mid: mid, hi: hi },
        `ITER ${iteration}`, `mid=${mid}, arr[${mid}]=${arr[mid]} < ${target} ‚Üí search right half.`,
        `<span class="highlight">arr[${mid}] = ${arr[mid]}</span> &lt; <span class="highlight">${target}</span>. Target must be in right half. Moving lo to <span class="highlight">${mid + 1}</span>.`
      );
      lo = mid + 1;
    } else {
      addStep(arr, states, { lo: lo, mid: mid, hi: hi },
        `ITER ${iteration}`, `mid=${mid}, arr[${mid}]=${arr[mid]} > ${target} ‚Üí search left half.`,
        `<span class="highlight">arr[${mid}] = ${arr[mid]}</span> &gt; <span class="highlight">${target}</span>. Target must be in left half. Moving hi to <span class="highlight">${mid - 1}</span>.`
      );
      hi = mid - 1;
    }
    iteration++;
  }

  if (!found) {
    addStep(arr, {}, {},
      'DONE', `${target} not found. Search space exhausted.`,
      `‚ùå <span class="highlight">${target}</span> not found. lo (${lo}) crossed hi (${hi}). Took <span class="highlight">${iteration - 1}</span> iterations.`
    );
  }
}

// ---------- REVERSE ----------
function buildReverse() {
  if (arr.length <= 1) { explain('‚ö†Ô∏è Array has 0 or 1 elements ‚Äî already reversed.'); return; }
  setComplexity('O(n)', 'O(1)', 'Reverse (Two-Pointer)');

  addStep(arr, {}, {},
    'INIT', `Reversing array using two-pointer technique.`,
    `Two pointers: <span class="highlight">left = 0</span>, <span class="highlight">right = ${arr.length - 1}</span>. Swap and move inward until they meet. O(n) time, O(1) space.`
  );

  let left = 0, right = arr.length - 1;
  let step = 1;
  while (left < right) {
    addStep(arr, { [left]: 'active', [right]: 'active' }, { lo: left, hi: right },
      `SWAP ${step}`, `Swapping arr[${left}]=${arr[left]} ‚Üî arr[${right}]=${arr[right]}.`,
      `Swapping <span class="highlight">${arr[left]}</span> (index ${left}) with <span class="highlight">${arr[right]}</span> (index ${right}).`
    );

    [arr[left], arr[right]] = [arr[right], arr[left]];

    addStep(arr, { [left]: 'found', [right]: 'found' }, { lo: left, hi: right },
      `SWAP ${step}`, `Swapped! arr[${left}]=${arr[left]}, arr[${right}]=${arr[right]}.`,
      `After swap: arr[${left}] = <span class="highlight">${arr[left]}</span>, arr[${right}] = <span class="highlight">${arr[right]}</span>. Moving pointers inward.`
    );

    left++;
    right--;
    step++;
  }

  const allSorted = {};
  arr.forEach((_, i) => allSorted[i] = 'sorted');
  addStep(arr, allSorted, {},
    'DONE', `Reverse complete. ${step - 1} swaps performed.`,
    `‚úÖ Array reversed in-place with <span class="highlight">${step - 1}</span> swaps. Two-pointer technique ‚Äî O(n/2) = O(n) time, O(1) space.`
  );
}

// ---------- FIND MIN/MAX ----------
function buildFindMinMax() {
  if (arr.length === 0) { explain('‚ö†Ô∏è Array is empty.'); return; }
  setComplexity('O(n)', 'O(1)', 'Find Min/Max');

  let min = arr[0], minIdx = 0, max = arr[0], maxIdx = 0;

  addStep(arr, { 0: 'active' }, { i: 0 },
    'INIT', `Starting with arr[0]=${arr[0]} as both min and max.`,
    `Initialize min = max = <span class="highlight">${arr[0]}</span>. Will scan entire array.`
  );

  for (let i = 1; i < arr.length; i++) {
    const states = { [i]: 'comparing' };
    if (minIdx !== i) states[minIdx] = 'found';
    if (maxIdx !== i) states[maxIdx] = 'active';

    let note = `arr[${i}]=${arr[i]}`;
    if (arr[i] < min) {
      min = arr[i]; minIdx = i;
      note += ` ‚Üí new MIN`;
    } else if (arr[i] > max) {
      max = arr[i]; maxIdx = i;
      note += ` ‚Üí new MAX`;
    } else {
      note += ` ‚Äî no change`;
    }

    addStep(arr, { [minIdx]: 'found', [maxIdx]: 'active', [i]: 'comparing' }, { i: i },
      `CMP[${i}]`, note,
      `Checking <span class="highlight">${arr[i]}</span>. Current min: <span class="highlight">${min}</span> (idx ${minIdx}), max: <span class="highlight">${max}</span> (idx ${maxIdx}).`
    );
  }

  addStep(arr, { [minIdx]: 'found', [maxIdx]: 'active' }, {},
    'DONE', `Min=${min} at [${minIdx}], Max=${max} at [${maxIdx}].`,
    `‚úÖ Min = <span class="highlight">${min}</span> at index <span class="highlight">${minIdx}</span>, Max = <span class="highlight">${max}</span> at index <span class="highlight">${maxIdx}</span>. Single pass ‚Äî O(n).`
  );
}

/* ============================================================
   EXECUTION ENGINE
   ============================================================ */

function execute() {
  if (isBusy) return;
  resetUI();
  buildSteps();
  if (steps.length === 0) return;
  isBusy = true;
  setStatus('Executing...', true);
  autoPlayAll();
}

function autoPlayAll() {
  stopAutoPlay();
  isPlaying = true;
  document.getElementById('autoBtn').textContent = '‚è∏ Pause';
  runNextStep();
}

function runNextStep() {
  if (stepIndex >= steps.length) {
    finishExecution();
    return;
  }
  applyStep(steps[stepIndex]);
  stepIndex++;
  autoInterval = setTimeout(runNextStep, animSpeed);
}

function stepThrough() {
  if (steps.length === 0 || stepIndex >= steps.length) {
    // Build new steps if not already built
    if (steps.length === 0) {
      buildSteps();
      if (steps.length === 0) return;
      isBusy = true;
      setStatus('Stepping...', true);
    } else {
      finishExecution();
      return;
    }
  }
  stopAutoPlay();
  applyStep(steps[stepIndex]);
  stepIndex++;
  if (stepIndex >= steps.length) {
    setTimeout(finishExecution, 300);
  }
}

function toggleAutoPlay() {
  if (isPlaying) {
    stopAutoPlay();
  } else {
    if (steps.length === 0) {
      buildSteps();
      if (steps.length === 0) return;
      isBusy = true;
      setStatus('Auto-playing...', true);
    }
    autoPlayAll();
  }
}

function stopAutoPlay() {
  isPlaying = false;
  if (autoInterval) clearTimeout(autoInterval);
  autoInterval = null;
  document.getElementById('autoBtn').textContent = '‚èØ Auto';
}

function applyStep(step) {
  arr = [...step.arr];
  renderArray(step.cellStates, step.pointers);
  addLog(step.logStep, step.logText);
  explain(step.explanationHTML);
}

function finishExecution() {
  stopAutoPlay();
  isBusy = false;
  setStatus('Complete', false);
  renderArray();
}

function resetViz() {
  resetUI();
  renderArray();
}
</script>
</body>
</html>