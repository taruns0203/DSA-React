<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>‚öîÔ∏è Divide & Conquer Visualizer - FAANG Interview Prep</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #0c0c1e 0%,
          #1a1a3e 50%,
          #2d1b4e 100%
        );
        min-height: 100vh;
        color: #e4e4e4;
        padding: 20px;
      }

      .container {
        max-width: 1700px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 20px;
      }

      h1 {
        font-size: 2.2rem;
        background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
      }

      .subtitle {
        color: #8892b0;
        font-size: 1rem;
      }

      .main-layout {
        display: grid;
        grid-template-columns: 280px 1fr 300px;
        gap: 20px;
      }

      .panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      .panel-title {
        font-size: 0.95rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #feca57;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .panel-title::before {
        content: "";
        width: 4px;
        height: 18px;
        background: linear-gradient(180deg, #ff6b6b, #feca57);
        border-radius: 2px;
      }

      /* Controls Panel */
      .input-group {
        margin-bottom: 15px;
      }

      .input-group label {
        display: block;
        margin-bottom: 6px;
        color: #8892b0;
        font-size: 0.85rem;
      }

      input[type="text"],
      select {
        width: 100%;
        padding: 10px 14px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 0.95rem;
        transition: all 0.3s;
      }

      input[type="text"]:focus,
      select:focus {
        outline: none;
        border-color: #feca57;
        box-shadow: 0 0 20px rgba(254, 202, 87, 0.2);
      }

      .btn {
        padding: 10px 16px;
        border: none;
        border-radius: 10px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #ff6b6b, #feca57);
        color: #1a1a2e;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(254, 202, 87, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #e4e4e4;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .btn-group {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
      }

      .btn-icon {
        width: 42px;
        height: 42px;
        padding: 0;
        font-size: 1.1rem;
      }

      .speed-control {
        margin-top: 15px;
      }

      .speed-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
        appearance: none;
        outline: none;
        margin-top: 8px;
      }

      .speed-slider::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6b6b, #feca57);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(254, 202, 87, 0.5);
      }

      .speed-value {
        text-align: center;
        color: #feca57;
        font-weight: 600;
        margin-top: 5px;
      }

      /* Algorithm tabs */
      .algo-tabs {
        display: flex;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 4px;
        margin-bottom: 15px;
      }

      .algo-tab {
        flex: 1;
        padding: 10px 8px;
        border: none;
        background: transparent;
        color: #8892b0;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s;
      }

      .algo-tab.active {
        background: linear-gradient(135deg, #ff6b6b, #feca57);
        color: #1a1a2e;
      }

      /* Stats */
      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
      }

      .stat-box {
        background: rgba(0, 0, 0, 0.3);
        padding: 12px;
        border-radius: 10px;
        text-align: center;
      }

      .stat-value {
        font-size: 1.4rem;
        font-weight: 700;
        color: #48dbfb;
      }

      .stat-label {
        font-size: 0.7rem;
        color: #8892b0;
        margin-top: 4px;
      }

      /* Visualization Panel */
      .visualization-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* Array visualization */
      .array-container {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 20px;
        min-height: 120px;
      }

      .array-label {
        font-size: 0.85rem;
        color: #8892b0;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .array-label .phase {
        background: rgba(254, 202, 87, 0.2);
        color: #feca57;
        padding: 3px 10px;
        border-radius: 20px;
        font-size: 0.75rem;
      }

      .array-bars {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 4px;
        height: 80px;
      }

      .bar {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.3s ease;
      }

      .bar-visual {
        width: 40px;
        border-radius: 6px 6px 0 0;
        transition: all 0.3s ease;
        position: relative;
      }

      .bar-value {
        font-size: 0.8rem;
        font-weight: 600;
        margin-top: 5px;
        color: #e4e4e4;
      }

      .bar-visual.default {
        background: linear-gradient(180deg, #48dbfb, #0abde3);
      }

      .bar-visual.comparing {
        background: linear-gradient(180deg, #feca57, #ff9f43);
        box-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
      }

      .bar-visual.swapping {
        background: linear-gradient(180deg, #ff6b6b, #ee5a24);
        animation: pulse 0.5s ease infinite;
      }

      .bar-visual.sorted {
        background: linear-gradient(180deg, #26de81, #20bf6b);
      }

      .bar-visual.pivot {
        background: linear-gradient(180deg, #a55eea, #8854d0);
        box-shadow: 0 0 20px rgba(165, 94, 234, 0.5);
      }

      .bar-visual.left-part {
        background: linear-gradient(180deg, #fd79a8, #e84393);
      }

      .bar-visual.right-part {
        background: linear-gradient(180deg, #74b9ff, #0984e3);
      }

      .bar-visual.merged {
        background: linear-gradient(180deg, #55efc4, #00b894);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(1.05);
        }
      }

      /* Recursion Tree */
      .tree-container {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 20px;
        min-height: 280px;
        overflow: auto;
      }

      .tree-svg {
        width: 100%;
        min-height: 250px;
      }

      .tree-node {
        transition: all 0.3s;
      }

      .node-rect {
        rx: 8;
        ry: 8;
        stroke-width: 2;
        transition: all 0.3s;
      }

      .node-rect.pending {
        fill: rgba(255, 255, 255, 0.05);
        stroke: rgba(255, 255, 255, 0.2);
      }

      .node-rect.dividing {
        fill: rgba(254, 202, 87, 0.2);
        stroke: #feca57;
        animation: glow-yellow 1s infinite;
      }

      .node-rect.conquering {
        fill: rgba(72, 219, 251, 0.2);
        stroke: #48dbfb;
      }

      .node-rect.merging {
        fill: rgba(38, 222, 129, 0.2);
        stroke: #26de81;
        animation: glow-green 1s infinite;
      }

      .node-rect.complete {
        fill: rgba(38, 222, 129, 0.2);
        stroke: #26de81;
      }

      @keyframes glow-yellow {
        0%,
        100% {
          filter: drop-shadow(0 0 5px rgba(254, 202, 87, 0.5));
        }
        50% {
          filter: drop-shadow(0 0 15px rgba(254, 202, 87, 0.8));
        }
      }

      @keyframes glow-green {
        0%,
        100% {
          filter: drop-shadow(0 0 5px rgba(38, 222, 129, 0.5));
        }
        50% {
          filter: drop-shadow(0 0 15px rgba(38, 222, 129, 0.8));
        }
      }

      .node-text {
        fill: #fff;
        font-size: 11px;
        font-weight: 600;
        text-anchor: middle;
        dominant-baseline: middle;
      }

      .tree-edge {
        stroke: rgba(255, 255, 255, 0.2);
        stroke-width: 2;
        fill: none;
      }

      .tree-edge.active {
        stroke: #feca57;
        stroke-width: 3;
      }

      /* Code Panel */
      .code-container {
        background: #0d1117;
        border-radius: 12px;
        padding: 15px;
        font-family: "Fira Code", "Consolas", monospace;
        font-size: 0.75rem;
        max-height: 180px;
        overflow-y: auto;
      }

      .code-line {
        padding: 3px 8px;
        border-radius: 4px;
        white-space: pre;
        transition: all 0.3s;
      }

      .code-line.highlight {
        background: rgba(254, 202, 87, 0.2);
        border-left: 3px solid #feca57;
      }

      .code-line .keyword {
        color: #ff79c6;
      }
      .code-line .function {
        color: #50fa7b;
      }
      .code-line .number {
        color: #bd93f9;
      }
      .code-line .comment {
        color: #6272a4;
      }

      /* Right Panel */
      .right-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* State Display */
      .state-display {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 12px;
      }

      .state-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 0.85rem;
      }

      .state-row:last-child {
        border-bottom: none;
      }

      .state-label {
        color: #8892b0;
      }

      .state-value {
        font-family: "Fira Code", monospace;
        color: #48dbfb;
        font-weight: 600;
      }

      /* Call Stack */
      .call-stack {
        max-height: 150px;
        overflow-y: auto;
      }

      .stack-frame {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 8px 12px;
        margin-bottom: 6px;
        border-left: 3px solid #48dbfb;
        font-family: "Fira Code", monospace;
        font-size: 0.8rem;
        transition: all 0.3s;
      }

      .stack-frame.active {
        border-left-color: #feca57;
        background: rgba(254, 202, 87, 0.1);
      }

      .stack-frame.complete {
        border-left-color: #26de81;
        opacity: 0.6;
      }

      /* Log Panel */
      .log-container {
        flex: 1;
        max-height: 200px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 12px;
      }

      .log-entry {
        padding: 5px 10px;
        border-radius: 6px;
        margin-bottom: 5px;
        font-size: 0.75rem;
        font-family: "Fira Code", monospace;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .log-entry.divide {
        background: rgba(254, 202, 87, 0.1);
        border-left: 3px solid #feca57;
      }

      .log-entry.conquer {
        background: rgba(72, 219, 251, 0.1);
        border-left: 3px solid #48dbfb;
      }

      .log-entry.merge {
        background: rgba(38, 222, 129, 0.1);
        border-left: 3px solid #26de81;
      }

      .log-entry.compare {
        background: rgba(255, 107, 107, 0.1);
        border-left: 3px solid #ff6b6b;
      }

      .log-entry.pivot {
        background: rgba(165, 94, 234, 0.1);
        border-left: 3px solid #a55eea;
      }

      .log-time {
        color: #6272a4;
        margin-right: 8px;
      }

      /* Legend */
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        margin-top: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.75rem;
      }

      .legend-color {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #6272a4;
        padding: 20px;
      }

      .empty-state-icon {
        font-size: 2rem;
        margin-bottom: 10px;
      }

      /* Responsive */
      @media (max-width: 1200px) {
        .main-layout {
          grid-template-columns: 1fr;
        }
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(254, 202, 87, 0.3);
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(254, 202, 87, 0.5);
      }

      /* Pointer indicators */
      .pointer-container {
        display: flex;
        justify-content: center;
        gap: 4px;
        margin-top: 5px;
      }

      .pointer {
        width: 40px;
        text-align: center;
        font-size: 0.7rem;
        font-weight: bold;
      }

      .pointer.left {
        color: #fd79a8;
      }
      .pointer.right {
        color: #74b9ff;
      }
      .pointer.mid {
        color: #feca57;
      }
      .pointer.pivot {
        color: #a55eea;
      }
      .pointer.i {
        color: #ff6b6b;
      }
      .pointer.j {
        color: #48dbfb;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>‚öîÔ∏è Divide & Conquer Visualizer</h1>
        <p class="subtitle">
          Watch Merge Sort & Quick Sort unfold step-by-step ‚Ä¢ FAANG Interview
          Prep
        </p>
      </header>

      <div class="main-layout">
        <!-- Left Panel - Controls -->
        <div class="panel">
          <div class="panel-title">Controls</div>

          <div class="algo-tabs">
            <button class="algo-tab active" data-algo="mergeSort">
              Merge Sort
            </button>
            <button class="algo-tab" data-algo="quickSort">Quick Sort</button>
          </div>

          <div class="input-group">
            <label>Array (comma-separated)</label>
            <input
              type="text"
              id="arrayInput"
              value="38, 27, 43, 3, 9, 82, 10"
            />
          </div>

          <div class="input-group">
            <label>Or use preset:</label>
            <select id="presetSelect">
              <option value="custom">Custom Input</option>
              <option value="random">Random (8 elements)</option>
              <option value="reversed">Reversed</option>
              <option value="nearlySorted">Nearly Sorted</option>
              <option value="fewUnique">Few Unique Values</option>
            </select>
          </div>

          <button
            class="btn btn-primary"
            id="startBtn"
            style="width: 100%; margin-bottom: 15px"
          >
            ‚ñ∂ Start Visualization
          </button>

          <div class="btn-group">
            <button
              class="btn btn-secondary btn-icon"
              id="stepBackBtn"
              title="Step Back"
            >
              ‚èÆ
            </button>
            <button
              class="btn btn-secondary btn-icon"
              id="playPauseBtn"
              title="Play/Pause"
            >
              ‚ñ∂
            </button>
            <button
              class="btn btn-secondary btn-icon"
              id="stepForwardBtn"
              title="Step Forward"
            >
              ‚è≠
            </button>
            <button
              class="btn btn-secondary btn-icon"
              id="resetBtn"
              title="Reset"
            >
              ‚Ü∫
            </button>
          </div>

          <div class="speed-control">
            <label>Animation Speed</label>
            <input
              type="range"
              class="speed-slider"
              id="speedSlider"
              min="100"
              max="2000"
              value="600"
            />
            <div class="speed-value" id="speedValue">600ms</div>
          </div>

          <div class="panel-title" style="margin-top: 20px">Statistics</div>
          <div class="stats-grid">
            <div class="stat-box">
              <div class="stat-value" id="comparisons">0</div>
              <div class="stat-label">Comparisons</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="swaps">0</div>
              <div class="stat-label">Swaps/Merges</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="recursionDepth">0</div>
              <div class="stat-label">Max Depth</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="currentStep">0/0</div>
              <div class="stat-label">Step</div>
            </div>
          </div>

          <div class="legend">
            <div class="legend-item">
              <div
                class="legend-color"
                style="background: linear-gradient(180deg, #feca57, #ff9f43)"
              ></div>
              <span>Comparing</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="background: linear-gradient(180deg, #a55eea, #8854d0)"
              ></div>
              <span>Pivot</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="background: linear-gradient(180deg, #26de81, #20bf6b)"
              ></div>
              <span>Sorted</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="background: linear-gradient(180deg, #fd79a8, #e84393)"
              ></div>
              <span>Left Half</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="background: linear-gradient(180deg, #74b9ff, #0984e3)"
              ></div>
              <span>Right Half</span>
            </div>
          </div>
        </div>

        <!-- Center Panel - Visualization -->
        <div class="visualization-panel">
          <div class="panel">
            <div class="panel-title">Array Visualization</div>
            <div class="array-container">
              <div class="array-label">
                <span>Current Array</span>
                <span class="phase" id="currentPhase">Ready</span>
              </div>
              <div class="array-bars" id="arrayBars"></div>
              <div class="pointer-container" id="pointerContainer"></div>
            </div>
          </div>

          <div class="panel" style="flex: 1">
            <div class="panel-title">Recursion Tree</div>
            <div class="tree-container" id="treeContainer">
              <svg class="tree-svg" id="treeSvg"></svg>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">Code Execution</div>
            <div class="code-container" id="codeContainer"></div>
          </div>
        </div>

        <!-- Right Panel - State & Log -->
        <div class="right-panel">
          <div class="panel">
            <div class="panel-title">Current State</div>
            <div class="state-display">
              <div class="state-row">
                <span class="state-label">Operation</span>
                <span class="state-value" id="stateOp">‚Äî</span>
              </div>
              <div class="state-row">
                <span class="state-label">Range</span>
                <span class="state-value" id="stateRange">‚Äî</span>
              </div>
              <div class="state-row">
                <span class="state-label">Left</span>
                <span class="state-value" id="stateLeft">‚Äî</span>
              </div>
              <div class="state-row">
                <span class="state-label">Right</span>
                <span class="state-value" id="stateRight">‚Äî</span>
              </div>
              <div class="state-row">
                <span class="state-label">Depth</span>
                <span class="state-value" id="stateDepth">‚Äî</span>
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">Call Stack</div>
            <div class="call-stack" id="callStack">
              <div class="empty-state">
                <span>Stack empty</span>
              </div>
            </div>
          </div>

          <div class="panel" style="flex: 1">
            <div class="panel-title">Execution Log</div>
            <div class="log-container" id="logContainer">
              <div class="empty-state">
                <div class="empty-state-icon">üìã</div>
                <span>Press Start to begin</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ==================== STATE ====================
      const state = {
        algorithm: "mergeSort",
        originalArray: [38, 27, 43, 3, 9, 82, 10],
        array: [],
        steps: [],
        currentStepIndex: -1,
        isPlaying: false,
        speed: 600,
        playInterval: null,
        stats: {
          comparisons: 0,
          swaps: 0,
          maxDepth: 0,
        },
        treeNodes: [],
      };

      // ==================== CODE DEFINITIONS ====================
      const codeDefinitions = {
        mergeSort: [
          { text: "function mergeSort(arr, l, r) {", line: "func" },
          { text: "  if (l >= r) return;", line: "base" },
          { text: "  const mid = Math.floor((l+r)/2);", line: "mid" },
          { text: "  mergeSort(arr, l, mid);", line: "left" },
          { text: "  mergeSort(arr, mid+1, r);", line: "right" },
          { text: "  merge(arr, l, mid, r);", line: "merge" },
          { text: "}", line: "end" },
        ],
        quickSort: [
          { text: "function quickSort(arr, l, r) {", line: "func" },
          { text: "  if (l >= r) return;", line: "base" },
          { text: "  const pivot = partition(arr, l, r);", line: "partition" },
          { text: "  quickSort(arr, l, pivot - 1);", line: "left" },
          { text: "  quickSort(arr, pivot + 1, r);", line: "right" },
          { text: "}", line: "end" },
        ],
      };

      // ==================== STEP GENERATORS ====================
      function generateMergeSortSteps(arr) {
        const steps = [];
        const array = [...arr];
        let comparisons = 0;
        let merges = 0;
        let maxDepth = 0;
        let nodeId = 0;
        const treeNodes = [];

        function mergeSort(left, right, depth, parentId) {
          const currentNodeId = nodeId++;
          maxDepth = Math.max(maxDepth, depth);

          treeNodes.push({
            id: currentNodeId,
            parentId,
            left,
            right,
            depth,
            array: array.slice(left, right + 1),
          });

          steps.push({
            type: "divide",
            nodeId: currentNodeId,
            left,
            right,
            depth,
            array: [...array],
            line: "func",
            action: `Divide: [${left}..${right}]`,
            comparisons,
            merges,
            maxDepth,
          });

          if (left >= right) {
            steps.push({
              type: "base-case",
              nodeId: currentNodeId,
              left,
              right,
              depth,
              array: [...array],
              line: "base",
              action: `Base case: single element [${array[left]}]`,
              comparisons,
              merges,
              maxDepth,
            });
            return;
          }

          const mid = Math.floor((left + right) / 2);

          steps.push({
            type: "calculate-mid",
            nodeId: currentNodeId,
            left,
            right,
            mid,
            depth,
            array: [...array],
            line: "mid",
            action: `Mid = ${mid}`,
            comparisons,
            merges,
            maxDepth,
          });

          // Recurse left
          steps.push({
            type: "recurse-left",
            nodeId: currentNodeId,
            left,
            right,
            mid,
            depth,
            array: [...array],
            line: "left",
            action: `Recurse left [${left}..${mid}]`,
            comparisons,
            merges,
            maxDepth,
          });

          mergeSort(left, mid, depth + 1, currentNodeId);

          // Recurse right
          steps.push({
            type: "recurse-right",
            nodeId: currentNodeId,
            left,
            right,
            mid,
            depth,
            array: [...array],
            line: "right",
            action: `Recurse right [${mid + 1}..${right}]`,
            comparisons,
            merges,
            maxDepth,
          });

          mergeSort(mid + 1, right, depth + 1, currentNodeId);

          // Merge
          steps.push({
            type: "merge-start",
            nodeId: currentNodeId,
            left,
            right,
            mid,
            depth,
            array: [...array],
            line: "merge",
            action: `Merging [${left}..${mid}] and [${mid + 1}..${right}]`,
            comparisons,
            merges,
            maxDepth,
          });

          // Actual merge
          const leftArr = array.slice(left, mid + 1);
          const rightArr = array.slice(mid + 1, right + 1);
          let i = 0,
            j = 0,
            k = left;

          while (i < leftArr.length && j < rightArr.length) {
            comparisons++;

            steps.push({
              type: "merge-compare",
              nodeId: currentNodeId,
              left,
              right,
              mid,
              depth,
              comparing: [left + i, mid + 1 + j],
              leftVal: leftArr[i],
              rightVal: rightArr[j],
              array: [...array],
              line: "merge",
              action: `Compare ${leftArr[i]} vs ${rightArr[j]}`,
              comparisons,
              merges,
              maxDepth,
            });

            if (leftArr[i] <= rightArr[j]) {
              array[k] = leftArr[i];
              i++;
            } else {
              array[k] = rightArr[j];
              j++;
            }
            merges++;
            k++;

            steps.push({
              type: "merge-place",
              nodeId: currentNodeId,
              left,
              right,
              mid,
              depth,
              array: [...array],
              line: "merge",
              action: `Placed ${array[k - 1]} at index ${k - 1}`,
              comparisons,
              merges,
              maxDepth,
            });
          }

          while (i < leftArr.length) {
            array[k] = leftArr[i];
            i++;
            k++;
            merges++;
          }

          while (j < rightArr.length) {
            array[k] = rightArr[j];
            j++;
            k++;
            merges++;
          }

          steps.push({
            type: "merge-complete",
            nodeId: currentNodeId,
            left,
            right,
            mid,
            depth,
            array: [...array],
            merged: array.slice(left, right + 1),
            line: "merge",
            action: `Merged: [${array.slice(left, right + 1).join(", ")}]`,
            comparisons,
            merges,
            maxDepth,
          });
        }

        mergeSort(0, array.length - 1, 0, null);

        steps.push({
          type: "complete",
          array: [...array],
          action: "Sorting complete!",
          comparisons,
          merges,
          maxDepth,
        });

        return { steps, treeNodes };
      }

      function generateQuickSortSteps(arr) {
        const steps = [];
        const array = [...arr];
        let comparisons = 0;
        let swaps = 0;
        let maxDepth = 0;
        let nodeId = 0;
        const treeNodes = [];

        function quickSort(left, right, depth, parentId) {
          const currentNodeId = nodeId++;
          maxDepth = Math.max(maxDepth, depth);

          treeNodes.push({
            id: currentNodeId,
            parentId,
            left,
            right,
            depth,
            array: array.slice(left, right + 1),
          });

          steps.push({
            type: "call",
            nodeId: currentNodeId,
            left,
            right,
            depth,
            array: [...array],
            line: "func",
            action: `QuickSort [${left}..${right}]`,
            comparisons,
            swaps,
            maxDepth,
          });

          if (left >= right) {
            steps.push({
              type: "base-case",
              nodeId: currentNodeId,
              left,
              right,
              depth,
              array: [...array],
              line: "base",
              action:
                left === right
                  ? `Base case: [${array[left]}]`
                  : "Base case: empty range",
              comparisons,
              swaps,
              maxDepth,
            });
            return;
          }

          // Partition
          const pivotVal = array[right];
          steps.push({
            type: "pivot-select",
            nodeId: currentNodeId,
            left,
            right,
            depth,
            pivot: right,
            pivotVal,
            array: [...array],
            line: "partition",
            action: `Pivot selected: ${pivotVal} (index ${right})`,
            comparisons,
            swaps,
            maxDepth,
          });

          let i = left - 1;

          for (let j = left; j < right; j++) {
            comparisons++;

            steps.push({
              type: "partition-compare",
              nodeId: currentNodeId,
              left,
              right,
              depth,
              pivot: right,
              pivotVal,
              i,
              j,
              array: [...array],
              line: "partition",
              action: `Compare arr[${j}]=${array[j]} with pivot ${pivotVal}`,
              comparisons,
              swaps,
              maxDepth,
            });

            if (array[j] < pivotVal) {
              i++;
              if (i !== j) {
                [array[i], array[j]] = [array[j], array[i]];
                swaps++;

                steps.push({
                  type: "partition-swap",
                  nodeId: currentNodeId,
                  left,
                  right,
                  depth,
                  pivot: right,
                  i,
                  j,
                  array: [...array],
                  line: "partition",
                  action: `Swap arr[${i}] ‚Üî arr[${j}]`,
                  comparisons,
                  swaps,
                  maxDepth,
                });
              }
            }
          }

          // Place pivot
          const pivotIndex = i + 1;
          if (pivotIndex !== right) {
            [array[pivotIndex], array[right]] = [
              array[right],
              array[pivotIndex],
            ];
            swaps++;
          }

          steps.push({
            type: "pivot-placed",
            nodeId: currentNodeId,
            left,
            right,
            depth,
            pivotIndex,
            pivotVal,
            array: [...array],
            line: "partition",
            action: `Pivot ${pivotVal} placed at index ${pivotIndex}`,
            comparisons,
            swaps,
            maxDepth,
          });

          // Recurse left
          if (pivotIndex > left) {
            steps.push({
              type: "recurse-left",
              nodeId: currentNodeId,
              left,
              right: pivotIndex - 1,
              depth,
              array: [...array],
              line: "left",
              action: `Recurse left [${left}..${pivotIndex - 1}]`,
              comparisons,
              swaps,
              maxDepth,
            });
            quickSort(left, pivotIndex - 1, depth + 1, currentNodeId);
          }

          // Recurse right
          if (pivotIndex < right) {
            steps.push({
              type: "recurse-right",
              nodeId: currentNodeId,
              left: pivotIndex + 1,
              right,
              depth,
              array: [...array],
              line: "right",
              action: `Recurse right [${pivotIndex + 1}..${right}]`,
              comparisons,
              swaps,
              maxDepth,
            });
            quickSort(pivotIndex + 1, right, depth + 1, currentNodeId);
          }
        }

        quickSort(0, array.length - 1, 0, null);

        steps.push({
          type: "complete",
          array: [...array],
          action: "Sorting complete!",
          comparisons,
          swaps,
          maxDepth,
        });

        return { steps, treeNodes };
      }

      // ==================== RENDERING ====================
      function renderArray() {
        const container = document.getElementById("arrayBars");
        const pointerContainer = document.getElementById("pointerContainer");
        const step = state.steps[state.currentStepIndex];
        const arr = step?.array || state.originalArray;
        const maxVal = Math.max(...arr);

        let barsHTML = "";
        let pointersHTML = "";

        arr.forEach((val, idx) => {
          let barClass = "default";

          if (step) {
            if (step.type === "complete") {
              barClass = "sorted";
            } else if (step.comparing && step.comparing.includes(idx)) {
              barClass = "comparing";
            } else if (step.pivot === idx || step.pivotIndex === idx) {
              barClass = "pivot";
            } else if (
              step.type === "merge-complete" &&
              idx >= step.left &&
              idx <= step.right
            ) {
              barClass = "merged";
            } else if (step.left !== undefined && step.mid !== undefined) {
              if (idx >= step.left && idx <= step.mid) barClass = "left-part";
              else if (idx > step.mid && idx <= step.right)
                barClass = "right-part";
            }
          }

          const height = (val / maxVal) * 70 + 10;
          barsHTML += `
                    <div class="bar">
                        <div class="bar-visual ${barClass}" style="height: ${height}px;"></div>
                        <div class="bar-value">${val}</div>
                    </div>
                `;

          // Pointers
          let pointerText = "";
          if (step) {
            if (step.i === idx) pointerText = "i";
            if (step.j === idx) pointerText += (pointerText ? "," : "") + "j";
            if (step.pivot === idx) pointerText = "P";
            if (step.pivotIndex === idx) pointerText = "‚úì";
          }
          pointersHTML += `<div class="pointer ${step?.i === idx ? "i" : ""} ${step?.j === idx ? "j" : ""}">${pointerText}</div>`;
        });

        container.innerHTML = barsHTML;
        pointerContainer.innerHTML = pointersHTML;

        // Update phase label
        const phaseEl = document.getElementById("currentPhase");
        if (step) {
          const phaseMap = {
            divide: "Dividing",
            "base-case": "Base Case",
            "calculate-mid": "Calculate Mid",
            "recurse-left": "Recurse Left",
            "recurse-right": "Recurse Right",
            "merge-start": "Merging",
            "merge-compare": "Comparing",
            "merge-place": "Placing",
            "merge-complete": "Merged",
            call: "Dividing",
            "pivot-select": "Select Pivot",
            "partition-compare": "Partitioning",
            "partition-swap": "Swapping",
            "pivot-placed": "Pivot Placed",
            complete: "Complete!",
          };
          phaseEl.textContent = phaseMap[step.type] || step.type;
        } else {
          phaseEl.textContent = "Ready";
        }
      }

      function renderTree() {
        const svg = document.getElementById("treeSvg");
        const container = document.getElementById("treeContainer");

        if (state.treeNodes.length === 0) {
          svg.innerHTML = "";
          return;
        }

        const nodeWidth = 70;
        const nodeHeight = 30;
        const levelHeight = 60;
        const padding = 20;

        // Calculate positions
        const levels = {};
        state.treeNodes.forEach((node) => {
          if (!levels[node.depth]) levels[node.depth] = [];
          levels[node.depth].push(node);
        });

        const maxDepth = Math.max(...Object.keys(levels).map(Number));
        const maxNodesInLevel = Math.max(
          ...Object.values(levels).map((l) => l.length),
        );
        const svgWidth = Math.max(
          maxNodesInLevel * (nodeWidth + 20) + padding * 2,
          container.clientWidth - 40,
        );
        const svgHeight = (maxDepth + 1) * levelHeight + padding * 2;

        // Position nodes
        const nodePositions = new Map();
        Object.entries(levels).forEach(([depth, nodes]) => {
          const d = parseInt(depth);
          const totalWidth = nodes.length * nodeWidth + (nodes.length - 1) * 20;
          let startX = (svgWidth - totalWidth) / 2;

          nodes.forEach((node, i) => {
            nodePositions.set(node.id, {
              x: startX + i * (nodeWidth + 20),
              y: padding + d * levelHeight,
              node,
            });
          });
        });

        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        svg.style.minHeight = svgHeight + "px";

        let svgContent = "";

        // Draw edges
        state.treeNodes.forEach((node) => {
          if (node.parentId !== null) {
            const parentPos = nodePositions.get(node.parentId);
            const childPos = nodePositions.get(node.id);
            if (parentPos && childPos) {
              const isActive =
                state.steps[state.currentStepIndex]?.nodeId === node.id;
              svgContent += `<line class="tree-edge ${isActive ? "active" : ""}" 
                            x1="${parentPos.x + nodeWidth / 2}" y1="${parentPos.y + nodeHeight}"
                            x2="${childPos.x + nodeWidth / 2}" y2="${childPos.y}" />`;
            }
          }
        });

        // Draw nodes
        nodePositions.forEach((pos, nodeId) => {
          const node = pos.node;
          const nodeState = getNodeState(nodeId);
          const arrStr =
            node.array.length <= 4
              ? node.array.join(",")
              : node.array.slice(0, 3).join(",") + "..";

          svgContent += `
                    <g class="tree-node" transform="translate(${pos.x}, ${pos.y})">
                        <rect class="node-rect ${nodeState}" width="${nodeWidth}" height="${nodeHeight}" />
                        <text class="node-text" x="${nodeWidth / 2}" y="${nodeHeight / 2}">[${arrStr}]</text>
                    </g>
                `;
        });

        svg.innerHTML = svgContent;
      }

      function getNodeState(nodeId) {
        const currentStep = state.steps[state.currentStepIndex];
        if (!currentStep) return "pending";

        // Find steps related to this node
        const nodeSteps = state.steps
          .slice(0, state.currentStepIndex + 1)
          .filter((s) => s.nodeId === nodeId);

        if (nodeSteps.length === 0) return "pending";

        const lastStep = nodeSteps[nodeSteps.length - 1];

        if (
          lastStep.type === "merge-complete" ||
          lastStep.type === "pivot-placed"
        )
          return "complete";
        if (lastStep.type.includes("merge")) return "merging";
        if (lastStep.type === "base-case") return "complete";
        if (currentStep.nodeId === nodeId) return "dividing";

        return "conquering";
      }

      function renderCode() {
        const container = document.getElementById("codeContainer");
        const code = codeDefinitions[state.algorithm];
        const currentLine = state.steps[state.currentStepIndex]?.line;

        container.innerHTML = code
          .map((line) => {
            let text = line.text;
            text = text.replace(
              /\b(function|if|const|return)\b/g,
              '<span class="keyword">$1</span>',
            );
            text = text.replace(
              /\b(mergeSort|quickSort|merge|partition)\b/g,
              '<span class="function">$1</span>',
            );
            text = text.replace(/\b(\d+)\b/g, '<span class="number">$1</span>');

            const isHighlight = line.line === currentLine;
            return `<div class="code-line ${isHighlight ? "highlight" : ""}">${text}</div>`;
          })
          .join("");
      }

      function renderCallStack() {
        const container = document.getElementById("callStack");
        const step = state.steps[state.currentStepIndex];

        if (!step || state.currentStepIndex < 0) {
          container.innerHTML =
            '<div class="empty-state"><span>Stack empty</span></div>';
          return;
        }

        // Build stack from steps
        const stack = [];
        const funcName =
          state.algorithm === "mergeSort" ? "mergeSort" : "quickSort";

        for (let i = 0; i <= state.currentStepIndex; i++) {
          const s = state.steps[i];
          if (s.type === "divide" || s.type === "call") {
            stack.push({
              left: s.left,
              right: s.right,
              nodeId: s.nodeId,
              complete: false,
            });
          } else if (
            s.type === "merge-complete" ||
            s.type === "base-case" ||
            (s.type === "pivot-placed" && state.algorithm === "quickSort")
          ) {
            const frame = stack.find((f) => f.nodeId === s.nodeId);
            if (frame) frame.complete = true;
          }
        }

        const activeStack = stack.filter((f) => !f.complete);

        if (activeStack.length === 0) {
          container.innerHTML =
            '<div class="empty-state"><span>Stack empty</span></div>';
          return;
        }

        container.innerHTML = activeStack
          .map((frame, i) => {
            const isActive = i === activeStack.length - 1;
            return `<div class="stack-frame ${isActive ? "active" : ""}">${funcName}(${frame.left}, ${frame.right})</div>`;
          })
          .reverse()
          .join("");
      }

      function renderLog() {
        const container = document.getElementById("logContainer");
        const logs = state.steps.slice(0, state.currentStepIndex + 1);

        if (logs.length === 0) {
          container.innerHTML =
            '<div class="empty-state"><div class="empty-state-icon">üìã</div><span>Press Start to begin</span></div>';
          return;
        }

        container.innerHTML = logs
          .slice(-20)
          .map((step, i) => {
            let className = "log-entry";
            if (step.type.includes("divide") || step.type === "call")
              className += " divide";
            else if (step.type.includes("merge")) className += " merge";
            else if (
              step.type.includes("pivot") ||
              step.type.includes("partition")
            )
              className += " pivot";
            else if (step.type.includes("compare")) className += " compare";
            else className += " conquer";

            const time = String(logs.indexOf(step) + 1).padStart(3, "0");
            return `<div class="${className}"><span class="log-time">#${time}</span>${step.action}</div>`;
          })
          .join("");

        container.scrollTop = container.scrollHeight;
      }

      function renderState() {
        const step = state.steps[state.currentStepIndex];

        document.getElementById("stateOp").textContent = step?.type || "‚Äî";
        document.getElementById("stateRange").textContent =
          step?.left !== undefined ? `[${step.left}..${step.right}]` : "‚Äî";
        document.getElementById("stateLeft").textContent =
          step?.left !== undefined
            ? `[${(step.array || state.originalArray).slice(step.left, (step.mid || step.right) + 1).join(", ")}]`
            : "‚Äî";
        document.getElementById("stateRight").textContent =
          step?.mid !== undefined
            ? `[${(step.array || state.originalArray).slice(step.mid + 1, step.right + 1).join(", ")}]`
            : "‚Äî";
        document.getElementById("stateDepth").textContent = step?.depth ?? "‚Äî";

        // Stats
        document.getElementById("comparisons").textContent =
          step?.comparisons || 0;
        document.getElementById("swaps").textContent =
          step?.merges || step?.swaps || 0;
        document.getElementById("recursionDepth").textContent =
          step?.maxDepth || 0;
        document.getElementById("currentStep").textContent =
          `${state.currentStepIndex + 1}/${state.steps.length}`;
      }

      function render() {
        renderArray();
        renderTree();
        renderCode();
        renderCallStack();
        renderLog();
        renderState();
      }

      // ==================== CONTROLS ====================
      function parseArray(input) {
        return input
          .split(",")
          .map((s) => parseInt(s.trim()))
          .filter((n) => !isNaN(n));
      }

      function generatePreset(type) {
        switch (type) {
          case "random":
            return Array.from(
              { length: 8 },
              () => Math.floor(Math.random() * 90) + 10,
            );
          case "reversed":
            return [80, 70, 60, 50, 40, 30, 20, 10];
          case "nearlySorted":
            return [10, 20, 30, 50, 40, 60, 70, 80];
          case "fewUnique":
            return [30, 10, 30, 20, 10, 30, 20, 10];
          default:
            return parseArray(document.getElementById("arrayInput").value);
        }
      }

      function start() {
        const arr = parseArray(document.getElementById("arrayInput").value);
        if (arr.length === 0 || arr.length > 12) {
          alert("Please enter 1-12 numbers");
          return;
        }

        state.originalArray = arr;
        state.array = [...arr];

        const generator =
          state.algorithm === "mergeSort"
            ? generateMergeSortSteps
            : generateQuickSortSteps;
        const result = generator(arr);
        state.steps = result.steps;
        state.treeNodes = result.treeNodes;
        state.currentStepIndex = 0;
        state.isPlaying = false;
        clearInterval(state.playInterval);

        renderCode();
        render();
      }

      function stepForward() {
        if (state.currentStepIndex < state.steps.length - 1) {
          state.currentStepIndex++;
          render();
        } else {
          pause();
        }
      }

      function stepBack() {
        if (state.currentStepIndex > 0) {
          state.currentStepIndex--;
          render();
        }
      }

      function play() {
        if (state.steps.length === 0) start();
        state.isPlaying = true;
        document.getElementById("playPauseBtn").textContent = "‚è∏";

        state.playInterval = setInterval(() => {
          if (state.currentStepIndex < state.steps.length - 1) {
            stepForward();
          } else {
            pause();
          }
        }, state.speed);
      }

      function pause() {
        state.isPlaying = false;
        document.getElementById("playPauseBtn").textContent = "‚ñ∂";
        clearInterval(state.playInterval);
      }

      function togglePlayPause() {
        state.isPlaying ? pause() : play();
      }

      function reset() {
        pause();
        state.steps = [];
        state.treeNodes = [];
        state.currentStepIndex = -1;

        document.getElementById("treeSvg").innerHTML = "";
        document.getElementById("callStack").innerHTML =
          '<div class="empty-state"><span>Stack empty</span></div>';
        document.getElementById("logContainer").innerHTML =
          '<div class="empty-state"><div class="empty-state-icon">üìã</div><span>Press Start to begin</span></div>';

        renderArray();
        renderCode();
        renderState();
      }

      // ==================== EVENT LISTENERS ====================
      document.querySelectorAll(".algo-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          document
            .querySelectorAll(".algo-tab")
            .forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          state.algorithm = tab.dataset.algo;
          reset();
          renderCode();
        });
      });

      document
        .getElementById("presetSelect")
        .addEventListener("change", (e) => {
          if (e.target.value !== "custom") {
            const arr = generatePreset(e.target.value);
            document.getElementById("arrayInput").value = arr.join(", ");
          }
        });

      document.getElementById("speedSlider").addEventListener("input", (e) => {
        state.speed = parseInt(e.target.value);
        document.getElementById("speedValue").textContent = state.speed + "ms";
        if (state.isPlaying) {
          pause();
          play();
        }
      });

      document.getElementById("startBtn").addEventListener("click", start);
      document
        .getElementById("playPauseBtn")
        .addEventListener("click", togglePlayPause);
      document
        .getElementById("stepForwardBtn")
        .addEventListener("click", stepForward);
      document
        .getElementById("stepBackBtn")
        .addEventListener("click", stepBack);
      document.getElementById("resetBtn").addEventListener("click", reset);

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.target.tagName === "INPUT") return;
        switch (e.key) {
          case " ":
            e.preventDefault();
            togglePlayPause();
            break;
          case "ArrowRight":
            stepForward();
            break;
          case "ArrowLeft":
            stepBack();
            break;
          case "r":
            reset();
            break;
          case "Enter":
            start();
            break;
        }
      });

      // Initialize
      renderCode();
      renderArray();
    </script>
  </body>
</html>
