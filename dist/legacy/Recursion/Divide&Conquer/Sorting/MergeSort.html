<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merge Sort - Interactive Whiteboard</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&family=Patrick+Hand&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Patrick Hand", cursive;
        background: #0f0f23;
        min-height: 100vh;
        padding: 20px;
      }

      .whiteboard {
        background: linear-gradient(
          135deg,
          #1a472a 0%,
          #2d5a3d 50%,
          #1a472a 100%
        );
        border-radius: 12px;
        padding: 35px;
        max-width: 1400px;
        margin: 0 auto;
        box-shadow:
          inset 0 0 100px rgba(0, 0, 0, 0.3),
          0 10px 40px rgba(0, 0, 0, 0.5);
        position: relative;
        overflow: hidden;
      }

      .whiteboard::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
        pointer-events: none;
      }

      .board-frame {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 15px solid #5d4037;
        border-radius: 12px;
        pointer-events: none;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
      }

      .title {
        font-family: "Caveat", cursive;
        font-size: 3rem;
        color: #fff;
        text-align: center;
        margin-bottom: 8px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .subtitle {
        font-size: 1.2rem;
        color: #a8e6cf;
        text-align: center;
        margin-bottom: 20px;
        position: relative;
      }

      .chalk-line {
        height: 3px;
        background: linear-gradient(90deg, transparent, #fff, transparent);
        margin: 15px auto;
        width: 60%;
        opacity: 0.5;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 25px;
        position: relative;
      }

      @media (max-width: 1100px) {
        .main-container {
          grid-template-columns: 1fr;
        }
      }

      .visualization-area {
        position: relative;
      }

      .step-explanation {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 18px;
        border-left: 5px solid #ffeb3b;
        margin-bottom: 20px;
        position: relative;
      }

      .step-explanation h3 {
        color: #ffeb3b;
        font-size: 1.3rem;
        margin-bottom: 8px;
      }

      .step-explanation p {
        color: #fff;
        font-size: 1.1rem;
        line-height: 1.5;
      }

      .code-display {
        font-family: "Courier New", monospace;
        color: #a5d6a7;
        font-size: 0.95rem;
        background: rgba(0, 0, 0, 0.3);
        padding: 10px 15px;
        border-radius: 8px;
        margin-top: 10px;
        overflow-x: auto;
      }

      .highlight {
        background: rgba(255, 235, 59, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
      }

      .tree-section {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        overflow-x: auto;
      }

      .section-title {
        color: #ffeb3b;
        font-size: 1.3rem;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .tree-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        min-height: 300px;
      }

      .tree-level {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        width: 100%;
      }

      .tree-node {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.4s ease;
      }

      .node-array {
        display: flex;
        gap: 3px;
        padding: 8px 12px;
        background: linear-gradient(180deg, #37474f 0%, #263238 100%);
        border-radius: 10px;
        border: 3px solid #546e7a;
        transition: all 0.3s ease;
        position: relative;
      }

      .node-array.active {
        border-color: #ffeb3b;
        box-shadow: 0 0 20px rgba(255, 235, 59, 0.5);
        transform: scale(1.05);
      }

      .node-array.splitting {
        border-color: #ff7043;
        box-shadow: 0 0 20px rgba(255, 112, 67, 0.5);
        animation: pulse 0.5s ease infinite;
      }

      .node-array.merging {
        border-color: #4caf50;
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
      }

      .node-array.merged {
        background: linear-gradient(180deg, #2e7d32 0%, #1b5e20 100%);
        border-color: #4caf50;
      }

      .node-array.comparing {
        border-color: #e91e63;
        box-shadow: 0 0 20px rgba(233, 30, 99, 0.5);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.08);
        }
      }

      .node-element {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, #ffeb3b 0%, #ffc107 100%);
        border-radius: 6px;
        font-size: 1.3rem;
        font-weight: bold;
        color: #333;
        transition: all 0.3s ease;
      }

      .node-element.highlight-left {
        background: linear-gradient(180deg, #2196f3 0%, #1976d2 100%);
        color: #fff;
      }

      .node-element.highlight-right {
        background: linear-gradient(180deg, #ff9800 0%, #f57c00 100%);
        color: #fff;
      }

      .node-element.comparing {
        background: linear-gradient(180deg, #e91e63 0%, #c2185b 100%);
        color: #fff;
        transform: scale(1.15);
      }

      .node-element.placed {
        background: linear-gradient(180deg, #4caf50 0%, #388e3c 100%);
        color: #fff;
      }

      .node-element.sorted {
        background: linear-gradient(180deg, #66bb6a 0%, #43a047 100%);
        color: #fff;
      }

      .node-label {
        color: #90caf9;
        font-size: 0.9rem;
        margin-top: 5px;
      }

      .connector {
        width: 2px;
        height: 20px;
        background: rgba(255, 255, 255, 0.3);
      }

      .merge-visualization {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        display: none;
      }

      .merge-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .merge-inputs {
        display: flex;
        justify-content: center;
        gap: 50px;
        align-items: flex-start;
      }

      .merge-array {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .merge-array-label {
        color: #90caf9;
        font-size: 1.1rem;
        margin-bottom: 8px;
      }

      .merge-array-elements {
        display: flex;
        gap: 5px;
      }

      .merge-element {
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        font-size: 1.5rem;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .merge-element.left {
        background: linear-gradient(180deg, #2196f3 0%, #1976d2 100%);
        color: #fff;
        border: 3px solid #64b5f6;
      }

      .merge-element.right {
        background: linear-gradient(180deg, #ff9800 0%, #f57c00 100%);
        color: #fff;
        border: 3px solid #ffb74d;
      }

      .merge-element.used {
        opacity: 0.3;
      }

      .merge-element.active {
        transform: scale(1.2);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      }

      .merge-arrow {
        font-size: 2rem;
        color: #fff;
        margin: 10px 0;
      }

      .merge-result {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .merge-result-label {
        color: #a5d6a7;
        font-size: 1.1rem;
        margin-bottom: 8px;
      }

      .merge-result-elements {
        display: flex;
        gap: 5px;
      }

      .result-element {
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, #4caf50 0%, #388e3c 100%);
        border: 3px solid #81c784;
        border-radius: 8px;
        font-size: 1.5rem;
        font-weight: bold;
        color: #fff;
        transition: all 0.3s ease;
      }

      .result-element.empty {
        background: rgba(255, 255, 255, 0.1);
        border-style: dashed;
        color: rgba(255, 255, 255, 0.3);
      }

      .result-element.just-placed {
        animation: pop 0.3s ease;
      }

      @keyframes pop {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
      }

      .comparison-display {
        background: rgba(233, 30, 99, 0.2);
        border-radius: 10px;
        padding: 15px 25px;
        text-align: center;
        margin: 10px 0;
      }

      .comparison-text {
        color: #fff;
        font-size: 1.5rem;
      }

      .comparison-result {
        color: #ffeb3b;
        font-size: 1.2rem;
        margin-top: 5px;
      }

      .status-bar {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 12px;
        text-align: center;
        margin: 15px 0;
        position: relative;
      }

      .status-text {
        color: #fff;
        font-size: 1.2rem;
      }

      .status-text.success {
        color: #4caf50;
      }

      .status-text.action {
        color: #ff9800;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 12px;
        flex-wrap: wrap;
        margin: 15px 0;
        position: relative;
      }

      .btn {
        font-family: "Patrick Hand", cursive;
        font-size: 1.1rem;
        padding: 10px 22px;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(180deg, #4caf50 0%, #388e3c 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      }

      .btn-secondary {
        background: linear-gradient(180deg, #2196f3 0%, #1976d2 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
      }

      .btn-warning {
        background: linear-gradient(180deg, #ff9800 0%, #f57c00 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
      }

      .btn-danger {
        background: linear-gradient(180deg, #f44336 0%, #d32f2f 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
      }

      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin: 12px 0;
        position: relative;
      }

      .speed-label {
        color: #fff;
        font-size: 1rem;
      }

      .speed-slider {
        width: 120px;
        height: 8px;
        -webkit-appearance: none;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        outline: none;
      }

      .speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        background: #ffeb3b;
        border-radius: 50%;
        cursor: pointer;
      }

      .sidebar {
        position: relative;
      }

      .info-panel {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 12px;
        padding: 18px;
        margin-bottom: 15px;
      }

      .info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }

      .info-box {
        text-align: center;
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 8px;
      }

      .info-label {
        color: #a5d6a7;
        font-size: 0.95rem;
        margin-bottom: 4px;
      }

      .info-value {
        color: #fff;
        font-size: 1.4rem;
        font-family: "Caveat", cursive;
      }

      .call-stack-panel {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .stack-title {
        color: #a5d6a7;
        font-size: 1.1rem;
        margin-bottom: 10px;
        text-align: center;
      }

      .call-stack {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 200px;
        overflow-y: auto;
      }

      .stack-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 6px;
        color: #fff;
        font-size: 0.9rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .stack-item.active {
        background: linear-gradient(
          90deg,
          rgba(76, 175, 80, 0.3),
          rgba(76, 175, 80, 0.1)
        );
        border-left: 3px solid #4caf50;
      }

      .stack-item.merge-active {
        background: linear-gradient(
          90deg,
          rgba(33, 150, 243, 0.3),
          rgba(33, 150, 243, 0.1)
        );
        border-left: 3px solid #2196f3;
      }

      .complexity-box {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 12px;
        padding: 15px;
        text-align: center;
        position: relative;
      }

      .complexity-title {
        color: #a5d6a7;
        font-size: 1.1rem;
        margin-bottom: 10px;
      }

      .complexity-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .complexity-item {
        text-align: center;
      }

      .complexity-label {
        color: #90caf9;
        font-size: 0.85rem;
      }

      .complexity-value {
        color: #ffeb3b;
        font-size: 1.2rem;
        font-family: "Caveat", cursive;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        margin-top: 15px;
        padding-top: 12px;
        border-top: 2px dashed rgba(255, 255, 255, 0.2);
        position: relative;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .legend-color {
        width: 22px;
        height: 22px;
        border-radius: 4px;
        border: 2px solid #fff;
      }

      .legend-text {
        color: #fff;
        font-size: 0.9rem;
      }

      .phase-indicator {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 15px;
      }

      .phase {
        padding: 8px 20px;
        border-radius: 20px;
        color: #fff;
        font-size: 1rem;
        opacity: 0.4;
        transition: all 0.3s ease;
      }

      .phase.active {
        opacity: 1;
        transform: scale(1.1);
      }

      .phase-divide {
        background: linear-gradient(180deg, #ff7043 0%, #e64a19 100%);
      }

      .phase-conquer {
        background: linear-gradient(180deg, #4caf50 0%, #388e3c 100%);
      }
    </style>
  </head>
  <body>
    <div class="whiteboard">
      <div class="board-frame"></div>

      <h1 class="title">üîÄ Merge Sort Algorithm</h1>
      <p class="subtitle">
        Divide the array, conquer by sorting, then merge the results!
      </p>

      <div class="chalk-line"></div>

      <div class="phase-indicator">
        <div class="phase phase-divide" id="phase-divide">üì§ DIVIDE</div>
        <div class="phase phase-conquer" id="phase-conquer">
          üì• CONQUER & MERGE
        </div>
      </div>

      <div class="main-container">
        <div class="visualization-area">
          <div class="step-explanation">
            <h3 id="step-title">üéØ Merge Sort Overview</h3>
            <p id="step-description">
              Click "Start" to sort [38, 27, 43, 3, 9, 82, 10]. Merge Sort
              divides the array in half recursively until single elements, then
              merges them back in sorted order!
            </p>
            <div class="code-display" id="code-display">
              // Merge Sort: O(n log n) guaranteed<br />
              // 1. Divide: Split array in half<br />
              // 2. Conquer: Recursively sort halves<br />
              // 3. Merge: Combine sorted halves
            </div>
          </div>

          <div class="tree-section">
            <div class="section-title">üå≥ Recursion Tree</div>
            <div class="tree-container" id="tree-container">
              <!-- Tree will be generated here -->
            </div>
          </div>

          <div class="merge-visualization" id="merge-visualization">
            <div class="section-title">üîÑ Merge Operation</div>
            <div class="merge-container">
              <div class="merge-inputs">
                <div class="merge-array">
                  <div class="merge-array-label">Left Array</div>
                  <div class="merge-array-elements" id="merge-left"></div>
                </div>
                <div class="merge-array">
                  <div class="merge-array-label">Right Array</div>
                  <div class="merge-array-elements" id="merge-right"></div>
                </div>
              </div>
              <div
                class="comparison-display"
                id="comparison-display"
                style="display: none"
              >
                <div class="comparison-text" id="comparison-text">3 vs 9</div>
                <div class="comparison-result" id="comparison-result">
                  3 < 9, pick 3
                </div>
              </div>
              <div class="merge-arrow">‚¨áÔ∏è</div>
              <div class="merge-result">
                <div class="merge-result-label">Merged Result</div>
                <div class="merge-result-elements" id="merge-result"></div>
              </div>
            </div>
          </div>

          <div class="status-bar">
            <div class="status-text" id="status-text">
              Press "Start" to begin Merge Sort!
            </div>
          </div>

          <div class="controls">
            <button
              class="btn btn-primary"
              id="start-btn"
              onclick="startSort()"
            >
              ‚ñ∂Ô∏è Start
            </button>
            <button
              class="btn btn-secondary"
              id="step-btn"
              onclick="nextStep()"
              disabled
            >
              ‚è≠Ô∏è Next Step
            </button>
            <button
              class="btn btn-warning"
              id="auto-btn"
              onclick="toggleAuto()"
              disabled
            >
              üîÑ Auto Play
            </button>
            <button class="btn btn-danger" id="reset-btn" onclick="resetSort()">
              üîÉ Reset
            </button>
          </div>

          <div class="speed-control">
            <span class="speed-label">Speed:</span>
            <input
              type="range"
              class="speed-slider"
              id="speed-slider"
              min="200"
              max="2000"
              value="700"
            />
            <span class="speed-label" id="speed-value">Medium</span>
          </div>

          <div class="legend">
            <div class="legend-item">
              <div
                class="legend-color"
                style="
                  background: linear-gradient(180deg, #ffeb3b 0%, #ffc107 100%);
                "
              ></div>
              <span class="legend-text">Unsorted</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="
                  background: linear-gradient(180deg, #2196f3 0%, #1976d2 100%);
                "
              ></div>
              <span class="legend-text">Left Half</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="
                  background: linear-gradient(180deg, #ff9800 0%, #f57c00 100%);
                "
              ></div>
              <span class="legend-text">Right Half</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="
                  background: linear-gradient(180deg, #e91e63 0%, #c2185b 100%);
                "
              ></div>
              <span class="legend-text">Comparing</span>
            </div>
            <div class="legend-item">
              <div
                class="legend-color"
                style="
                  background: linear-gradient(180deg, #4caf50 0%, #388e3c 100%);
                "
              ></div>
              <span class="legend-text">Merged/Sorted</span>
            </div>
          </div>
        </div>

        <div class="sidebar">
          <div class="info-panel">
            <div class="section-title" style="font-size: 1.1rem">
              üìà Statistics
            </div>
            <div class="info-grid">
              <div class="info-box">
                <div class="info-label">Comparisons</div>
                <div class="info-value" id="comparisons">0</div>
              </div>
              <div class="info-box">
                <div class="info-label">Merges</div>
                <div class="info-value" id="merges">0</div>
              </div>
              <div class="info-box">
                <div class="info-label">Splits</div>
                <div class="info-value" id="splits">0</div>
              </div>
              <div class="info-box">
                <div class="info-label">Max Depth</div>
                <div class="info-value" id="depth">0</div>
              </div>
            </div>
          </div>

          <div class="call-stack-panel">
            <div class="stack-title">üìö Call Stack</div>
            <div class="call-stack" id="call-stack">
              <div class="stack-item" style="opacity: 0.5">
                <span>Waiting to start...</span>
              </div>
            </div>
          </div>

          <div class="complexity-box">
            <div class="complexity-title">üìä Complexity</div>
            <div class="complexity-grid">
              <div class="complexity-item">
                <div class="complexity-label">Best</div>
                <div class="complexity-value">O(n log n)</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Average</div>
                <div class="complexity-value">O(n log n)</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Worst</div>
                <div class="complexity-value">O(n log n)</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Space</div>
                <div class="complexity-value">O(n)</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Initial array
      const originalArray = [38, 27, 43, 3, 9, 82, 10];
      let n = originalArray.length;

      // Statistics
      let comparisons = 0;
      let mergeCount = 0;
      let splitCount = 0;
      let maxDepth = 0;

      // State
      let isRunning = false;
      let isAutoPlay = false;
      let autoPlayInterval = null;
      let steps = [];
      let currentStepIndex = 0;

      // Tree nodes storage
      let treeNodes = {};
      let nodeIdCounter = 0;

      // Speed control
      const speedSlider = document.getElementById("speed-slider");
      speedSlider.addEventListener("input", updateSpeed);

      function updateSpeed() {
        const value = speedSlider.value;
        const label = document.getElementById("speed-value");
        if (value < 600) label.textContent = "Fast";
        else if (value < 1400) label.textContent = "Medium";
        else label.textContent = "Slow";
      }

      function getSpeed() {
        return parseInt(speedSlider.value);
      }

      // Generate unique node ID
      function getNodeId() {
        return `node-${nodeIdCounter++}`;
      }

      // Generate all steps
      function generateSteps() {
        steps = [];
        nodeIdCounter = 0;
        treeNodes = {};

        function addStep(type, data) {
          steps.push({ type, ...data });
        }

        function mergeSort(arr, depth, parentId, side) {
          const nodeId = getNodeId();
          treeNodes[nodeId] = {
            array: [...arr],
            depth,
            parentId,
            side,
            merged: false,
          };

          addStep("show-node", {
            nodeId,
            array: [...arr],
            depth,
            parentId,
            side,
          });

          if (arr.length <= 1) {
            addStep("base-case", { nodeId, array: [...arr], depth });
            treeNodes[nodeId].merged = true;
            return arr;
          }

          const mid = Math.floor(arr.length / 2);
          const left = arr.slice(0, mid);
          const right = arr.slice(mid);

          addStep("split", {
            nodeId,
            array: [...arr],
            left: [...left],
            right: [...right],
            depth,
            mid,
          });

          addStep("recurse-left", { nodeId, depth });
          const sortedLeft = mergeSort(left, depth + 1, nodeId, "left");

          addStep("recurse-right", { nodeId, depth });
          const sortedRight = mergeSort(right, depth + 1, nodeId, "right");

          addStep("start-merge", {
            nodeId,
            left: [...sortedLeft],
            right: [...sortedRight],
            depth,
          });

          const merged = merge(sortedLeft, sortedRight, nodeId, depth);
          treeNodes[nodeId].array = [...merged];
          treeNodes[nodeId].merged = true;

          addStep("merge-complete", { nodeId, result: [...merged], depth });

          return merged;
        }

        function merge(left, right, nodeId, depth) {
          const result = [];
          let i = 0,
            j = 0;
          const leftCopy = [...left];
          const rightCopy = [...right];

          while (i < left.length && j < right.length) {
            addStep("compare", {
              nodeId,
              left: leftCopy,
              right: rightCopy,
              leftIdx: i,
              rightIdx: j,
              leftVal: left[i],
              rightVal: right[j],
              result: [...result],
              depth,
            });

            if (left[i] <= right[j]) {
              result.push(left[i]);
              addStep("pick-left", {
                nodeId,
                left: leftCopy,
                right: rightCopy,
                leftIdx: i,
                rightIdx: j,
                picked: left[i],
                result: [...result],
                depth,
              });
              i++;
            } else {
              result.push(right[j]);
              addStep("pick-right", {
                nodeId,
                left: leftCopy,
                right: rightCopy,
                leftIdx: i,
                rightIdx: j,
                picked: right[j],
                result: [...result],
                depth,
              });
              j++;
            }
          }

          while (i < left.length) {
            result.push(left[i]);
            addStep("copy-left", {
              nodeId,
              left: leftCopy,
              right: rightCopy,
              leftIdx: i,
              picked: left[i],
              result: [...result],
              depth,
            });
            i++;
          }

          while (j < right.length) {
            result.push(right[j]);
            addStep("copy-right", {
              nodeId,
              left: leftCopy,
              right: rightCopy,
              rightIdx: j,
              picked: right[j],
              result: [...result],
              depth,
            });
            j++;
          }

          return result;
        }

        addStep("start", { array: [...originalArray] });
        mergeSort([...originalArray], 0, null, null);
        addStep("complete", {
          array: steps[steps.length - 1].result || originalArray,
        });
      }

      function renderTree() {
        const container = document.getElementById("tree-container");
        container.innerHTML = "";

        // Group nodes by depth
        const levels = {};
        Object.entries(treeNodes).forEach(([id, node]) => {
          if (!levels[node.depth]) levels[node.depth] = [];
          levels[node.depth].push({ id, ...node });
        });

        // Render each level
        Object.keys(levels)
          .sort((a, b) => a - b)
          .forEach((depth) => {
            const levelDiv = document.createElement("div");
            levelDiv.className = "tree-level";
            levelDiv.id = `level-${depth}`;

            levels[depth].forEach((node) => {
              const nodeDiv = document.createElement("div");
              nodeDiv.className = "tree-node";
              nodeDiv.id = node.id;

              const arrayDiv = document.createElement("div");
              arrayDiv.className = "node-array";
              if (node.merged) arrayDiv.classList.add("merged");

              node.array.forEach((val, idx) => {
                const elem = document.createElement("div");
                elem.className = "node-element";
                elem.id = `${node.id}-elem-${idx}`;
                elem.textContent = val;
                arrayDiv.appendChild(elem);
              });

              nodeDiv.appendChild(arrayDiv);

              const label = document.createElement("div");
              label.className = "node-label";
              label.textContent = `[${node.array.join(", ")}]`;
              nodeDiv.appendChild(label);

              levelDiv.appendChild(nodeDiv);
            });

            container.appendChild(levelDiv);
          });
      }

      function updateStats() {
        document.getElementById("comparisons").textContent = comparisons;
        document.getElementById("merges").textContent = mergeCount;
        document.getElementById("splits").textContent = splitCount;
        document.getElementById("depth").textContent = maxDepth;
      }

      function setPhase(phase) {
        document
          .getElementById("phase-divide")
          .classList.toggle("active", phase === "divide");
        document
          .getElementById("phase-conquer")
          .classList.toggle("active", phase === "conquer");
      }

      function clearNodeHighlights() {
        document.querySelectorAll(".node-array").forEach((node) => {
          node.classList.remove("active", "splitting", "merging", "comparing");
        });
        document.querySelectorAll(".node-element").forEach((elem) => {
          elem.classList.remove(
            "highlight-left",
            "highlight-right",
            "comparing",
            "placed",
          );
        });
      }

      function highlightNode(nodeId, className) {
        const node = document.getElementById(nodeId);
        if (node) {
          const arrayDiv = node.querySelector(".node-array");
          if (arrayDiv) arrayDiv.classList.add(className);
        }
      }

      function setExplanation(title, description, code) {
        document.getElementById("step-title").textContent = title;
        document.getElementById("step-description").textContent = description;
        document.getElementById("code-display").innerHTML = code;
      }

      function setStatus(text, className = "") {
        const status = document.getElementById("status-text");
        status.textContent = text;
        status.className = "status-text " + className;
      }

      function showMergeVisualization(
        left,
        right,
        result,
        leftIdx = -1,
        rightIdx = -1,
      ) {
        const mergeVis = document.getElementById("merge-visualization");
        mergeVis.style.display = "block";

        const leftDiv = document.getElementById("merge-left");
        const rightDiv = document.getElementById("merge-right");
        const resultDiv = document.getElementById("merge-result");

        leftDiv.innerHTML = "";
        rightDiv.innerHTML = "";
        resultDiv.innerHTML = "";

        left.forEach((val, idx) => {
          const elem = document.createElement("div");
          elem.className = "merge-element left";
          elem.textContent = val;
          if (idx < leftIdx) elem.classList.add("used");
          if (idx === leftIdx) elem.classList.add("active");
          leftDiv.appendChild(elem);
        });

        right.forEach((val, idx) => {
          const elem = document.createElement("div");
          elem.className = "merge-element right";
          elem.textContent = val;
          if (idx < rightIdx) elem.classList.add("used");
          if (idx === rightIdx) elem.classList.add("active");
          rightDiv.appendChild(elem);
        });

        const totalSlots = left.length + right.length;
        for (let i = 0; i < totalSlots; i++) {
          const elem = document.createElement("div");
          elem.className = "result-element";
          if (i < result.length) {
            elem.textContent = result[i];
            if (i === result.length - 1) elem.classList.add("just-placed");
          } else {
            elem.classList.add("empty");
            elem.textContent = "?";
          }
          resultDiv.appendChild(elem);
        }
      }

      function hideMergeVisualization() {
        document.getElementById("merge-visualization").style.display = "none";
        document.getElementById("comparison-display").style.display = "none";
      }

      function showComparison(leftVal, rightVal, result) {
        const compDisplay = document.getElementById("comparison-display");
        compDisplay.style.display = "block";
        document.getElementById("comparison-text").textContent =
          `${leftVal} vs ${rightVal}`;
        document.getElementById("comparison-result").textContent = result;
      }

      function updateCallStack(operation, data) {
        const stack = document.getElementById("call-stack");

        if (operation === "push") {
          const item = document.createElement("div");
          item.className = "stack-item active";
          item.id = `stack-${data.nodeId}`;
          item.innerHTML = `<span>mergeSort([${data.array.join(",")}])</span>`;
          stack.appendChild(item);
        } else if (operation === "merge") {
          const item = document.getElementById(`stack-${data.nodeId}`);
          if (item) {
            item.classList.remove("active");
            item.classList.add("merge-active");
            item.innerHTML = `<span>merge() ‚Üí [${data.result.join(",")}]</span>`;
          }
        } else if (operation === "pop") {
          const item = document.getElementById(`stack-${data.nodeId}`);
          if (item) item.remove();
        }
      }

      function executeStep(step) {
        clearNodeHighlights();

        switch (step.type) {
          case "start":
            setPhase("divide");
            setExplanation(
              "üöÄ Starting Merge Sort!",
              `We'll sort [${step.array.join(", ")}] by recursively dividing it in half, then merging the sorted halves back together.`,
              "mergeSort(arr, 0, arr.length - 1)",
            );
            setStatus(`Starting Merge Sort on [${step.array.join(", ")}]`);
            hideMergeVisualization();
            break;

          case "show-node":
            maxDepth = Math.max(maxDepth, step.depth);
            updateStats();
            treeNodes[step.nodeId] = {
              array: step.array,
              depth: step.depth,
              parentId: step.parentId,
              side: step.side,
              merged: false,
            };
            renderTree();
            highlightNode(step.nodeId, "active");
            updateCallStack("push", { nodeId: step.nodeId, array: step.array });
            setExplanation(
              `üìç Processing [${step.array.join(", ")}]`,
              `At depth ${step.depth}, working on subarray [${step.array.join(", ")}]${step.side ? ` (${step.side} half)` : ""}.`,
              `mergeSort([${step.array.join(", ")}])  // depth ${step.depth}`,
            );
            setStatus(
              `Processing [${step.array.join(", ")}] at depth ${step.depth}`,
            );
            break;

          case "base-case":
            treeNodes[step.nodeId].merged = true;
            renderTree();
            highlightNode(step.nodeId, "merged");
            setExplanation(
              `‚úÖ Base Case: [${step.array.join(", ")}]`,
              `Array has ${step.array.length} element(s). A single element is already sorted! Return it as-is.`,
              `if (arr.length <= 1) return arr  // <span class="highlight">[${step.array.join(", ")}]</span>`,
            );
            setStatus(
              `Base case reached: [${step.array.join(", ")}] is sorted!`,
              "success",
            );
            updateCallStack("pop", { nodeId: step.nodeId });
            break;

          case "split":
            splitCount++;
            updateStats();
            highlightNode(step.nodeId, "splitting");
            setExplanation(
              `‚úÇÔ∏è Split: [${step.array.join(", ")}]`,
              `Dividing array at middle index ${step.mid}. Left: [${step.left.join(", ")}], Right: [${step.right.join(", ")}]`,
              `const mid = ${step.mid}<br>const left = [${step.left.join(", ")}]<br>const right = [${step.right.join(", ")}]`,
            );
            setStatus(
              `Splitting into [${step.left.join(", ")}] and [${step.right.join(", ")}]`,
              "action",
            );
            break;

          case "recurse-left":
            setPhase("divide");
            setExplanation(
              `‚¨ÖÔ∏è Recurse Left`,
              `Now recursively sorting the left half...`,
              `const sortedLeft = mergeSort(left)`,
            );
            setStatus(`Recursing into left half`);
            break;

          case "recurse-right":
            setPhase("divide");
            setExplanation(
              `‚û°Ô∏è Recurse Right`,
              `Now recursively sorting the right half...`,
              `const sortedRight = mergeSort(right)`,
            );
            setStatus(`Recursing into right half`);
            break;

          case "start-merge":
            setPhase("conquer");
            mergeCount++;
            updateStats();
            highlightNode(step.nodeId, "merging");
            showMergeVisualization(step.left, step.right, [], 0, 0);
            setExplanation(
              `üîÄ Start Merge`,
              `Both halves are sorted! Left: [${step.left.join(", ")}], Right: [${step.right.join(", ")}]. Now merge them in sorted order.`,
              `return merge([${step.left.join(", ")}], [${step.right.join(", ")}])`,
            );
            setStatus(
              `Merging [${step.left.join(", ")}] and [${step.right.join(", ")}]`,
              "action",
            );
            break;

          case "compare":
            comparisons++;
            updateStats();
            highlightNode(step.nodeId, "comparing");
            showMergeVisualization(
              step.left,
              step.right,
              step.result,
              step.leftIdx,
              step.rightIdx,
            );
            showComparison(
              step.leftVal,
              step.rightVal,
              step.leftVal <= step.rightVal
                ? `${step.leftVal} ‚â§ ${step.rightVal}, pick ${step.leftVal}`
                : `${step.leftVal} > ${step.rightVal}, pick ${step.rightVal}`,
            );
            setExplanation(
              `üîç Compare: ${step.leftVal} vs ${step.rightVal}`,
              `Comparing left[${step.leftIdx}]=${step.leftVal} with right[${step.rightIdx}]=${step.rightVal}. Pick the smaller one.`,
              `if (left[${step.leftIdx}] <= right[${step.rightIdx}])<br>if (<span class="highlight">${step.leftVal} <= ${step.rightVal}</span>)`,
            );
            setStatus(`Comparing ${step.leftVal} vs ${step.rightVal}`);
            break;

          case "pick-left":
            showMergeVisualization(
              step.left,
              step.right,
              step.result,
              step.leftIdx + 1,
              step.rightIdx,
            );
            document.getElementById("comparison-display").style.display =
              "none";
            setExplanation(
              `‚¨ÖÔ∏è Pick ${step.picked} from Left`,
              `${step.picked} is smaller (or equal). Add it to result: [${step.result.join(", ")}]`,
              `result.push(left[i])  // <span class="highlight">${step.picked}</span><br>i++`,
            );
            setStatus(
              `Picked ${step.picked} from left ‚Üí [${step.result.join(", ")}]`,
              "success",
            );
            break;

          case "pick-right":
            showMergeVisualization(
              step.left,
              step.right,
              step.result,
              step.leftIdx,
              step.rightIdx + 1,
            );
            document.getElementById("comparison-display").style.display =
              "none";
            setExplanation(
              `‚û°Ô∏è Pick ${step.picked} from Right`,
              `${step.picked} is smaller. Add it to result: [${step.result.join(", ")}]`,
              `result.push(right[j])  // <span class="highlight">${step.picked}</span><br>j++`,
            );
            setStatus(
              `Picked ${step.picked} from right ‚Üí [${step.result.join(", ")}]`,
              "success",
            );
            break;

          case "copy-left":
            showMergeVisualization(
              step.left,
              step.right,
              step.result,
              step.leftIdx + 1,
              step.right.length,
            );
            setExplanation(
              `üìã Copy ${step.picked} from Left`,
              `Right array exhausted. Copy remaining left element: ${step.picked}. Result: [${step.result.join(", ")}]`,
              `result.push(left[i])  // <span class="highlight">${step.picked}</span>`,
            );
            setStatus(
              `Copied ${step.picked} from remaining left elements`,
              "success",
            );
            break;

          case "copy-right":
            showMergeVisualization(
              step.left,
              step.right,
              step.result,
              step.left.length,
              step.rightIdx + 1,
            );
            setExplanation(
              `üìã Copy ${step.picked} from Right`,
              `Left array exhausted. Copy remaining right element: ${step.picked}. Result: [${step.result.join(", ")}]`,
              `result.push(right[j])  // <span class="highlight">${step.picked}</span>`,
            );
            setStatus(
              `Copied ${step.picked} from remaining right elements`,
              "success",
            );
            break;

          case "merge-complete":
            treeNodes[step.nodeId].array = step.result;
            treeNodes[step.nodeId].merged = true;
            renderTree();
            highlightNode(step.nodeId, "merged");
            showMergeVisualization([], [], step.result);
            updateCallStack("merge", {
              nodeId: step.nodeId,
              result: step.result,
            });
            setExplanation(
              `‚úÖ Merge Complete!`,
              `Merged result: [${step.result.join(", ")}]. This subarray is now sorted!`,
              `return [${step.result.join(", ")}]  // <span class="highlight">Sorted!</span>`,
            );
            setStatus(`Merge complete: [${step.result.join(", ")}]`, "success");
            setTimeout(() => {
              updateCallStack("pop", { nodeId: step.nodeId });
            }, 200);
            break;

          case "complete":
            hideMergeVisualization();
            renderTree();
            // Highlight all nodes as merged
            document.querySelectorAll(".node-array").forEach((node) => {
              node.classList.add("merged");
            });
            setExplanation(
              `üéâ Sorting Complete!`,
              `The array is now fully sorted: [${step.array.join(", ")}]. Merge Sort divided the problem ${splitCount} times and performed ${mergeCount} merges!`,
              `// Final: [${step.array.join(", ")}]<br>// Comparisons: ${comparisons}, Merges: ${mergeCount}`,
            );
            setStatus(`üéâ Sorted: [${step.array.join(", ")}]`, "success");
            document.getElementById("step-btn").disabled = true;
            document.getElementById("auto-btn").disabled = true;
            if (isAutoPlay) toggleAuto();
            break;
        }
      }

      function startSort() {
        if (isRunning) return;
        isRunning = true;

        generateSteps();
        currentStepIndex = 0;

        document.getElementById("start-btn").disabled = true;
        document.getElementById("step-btn").disabled = false;
        document.getElementById("auto-btn").disabled = false;

        executeStep(steps[currentStepIndex]);
      }

      function nextStep() {
        if (!isRunning || currentStepIndex >= steps.length - 1) return;
        currentStepIndex++;
        executeStep(steps[currentStepIndex]);
      }

      function toggleAuto() {
        isAutoPlay = !isAutoPlay;
        const btn = document.getElementById("auto-btn");

        if (isAutoPlay) {
          btn.textContent = "‚è∏Ô∏è Pause";
          btn.classList.remove("btn-warning");
          btn.classList.add("btn-danger");
          autoPlayInterval = setInterval(() => {
            if (currentStepIndex < steps.length - 1) {
              nextStep();
            } else {
              toggleAuto();
            }
          }, getSpeed());
        } else {
          btn.textContent = "üîÑ Auto Play";
          btn.classList.remove("btn-danger");
          btn.classList.add("btn-warning");
          if (autoPlayInterval) {
            clearInterval(autoPlayInterval);
            autoPlayInterval = null;
          }
        }
      }

      function resetSort() {
        if (isAutoPlay) toggleAuto();

        comparisons = 0;
        mergeCount = 0;
        splitCount = 0;
        maxDepth = 0;
        isRunning = false;
        steps = [];
        currentStepIndex = 0;
        treeNodes = {};
        nodeIdCounter = 0;

        document.getElementById("start-btn").disabled = false;
        document.getElementById("step-btn").disabled = true;
        document.getElementById("auto-btn").disabled = true;

        document.getElementById("tree-container").innerHTML = `
                <div class="tree-level">
                    <div class="tree-node">
                        <div class="node-array">
                            ${originalArray.map((v) => `<div class="node-element">${v}</div>`).join("")}
                        </div>
                        <div class="node-label">[${originalArray.join(", ")}]</div>
                    </div>
                </div>
            `;

        document.getElementById("call-stack").innerHTML =
          '<div class="stack-item" style="opacity: 0.5;"><span>Waiting to start...</span></div>';

        hideMergeVisualization();
        updateStats();
        setPhase("");

        setExplanation(
          "üéØ Merge Sort Overview",
          `Click "Start" to sort [${originalArray.join(", ")}]. Merge Sort divides the array in half recursively until single elements, then merges them back in sorted order!`,
          "// Merge Sort: O(n log n) guaranteed<br>// 1. Divide: Split array in half<br>// 2. Conquer: Recursively sort halves<br>// 3. Merge: Combine sorted halves",
        );
        setStatus('Press "Start" to begin Merge Sort!');
      }

      // Initialize
      resetSort();
    </script>
  </body>
</html>
