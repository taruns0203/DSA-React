<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interweaving Approach - Copy List with Random Pointer</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;600;700&family=Kalam:wght@300;400;700&family=Fira+Code:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Kalam", cursive;
        background: #1a1a2e;
        min-height: 100vh;
        overflow-x: hidden;
      }

      /* Chalkboard style */
      .chalkboard {
        background: linear-gradient(
          135deg,
          #2d4a3e 0%,
          #1e3329 50%,
          #2a4238 100%
        );
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        min-height: 100vh;
        position: relative;
      }

      /* Wooden frame */
      .chalkboard::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 16px solid #5d4037;
        border-image: linear-gradient(
            135deg,
            #8d6e63,
            #5d4037,
            #4e342e,
            #6d4c41
          )
          1;
        pointer-events: none;
        z-index: 1000;
        box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5),
          0 0 30px rgba(0, 0, 0, 0.8);
      }

      /* Chalk dust effect */
      .chalkboard::after {
        content: "";
        position: fixed;
        bottom: 16px;
        left: 16px;
        right: 16px;
        height: 4px;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.3),
          rgba(255, 255, 255, 0.1)
        );
        pointer-events: none;
        z-index: 1001;
      }

      .container {
        max-width: 1500px;
        margin: 0 auto;
        padding: 30px 50px;
      }

      /* Chalk text effect */
      .chalk-text {
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.5),
          0 0 10px rgba(255, 255, 255, 0.3);
      }

      /* Title */
      .title {
        font-family: "Caveat", cursive;
        font-size: 3.5rem;
        font-weight: 700;
        text-align: center;
        margin-bottom: 5px;
        color: #ffeaa7;
        text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3),
          0 0 20px rgba(255, 234, 167, 0.5);
      }

      .subtitle {
        font-family: "Kalam", cursive;
        font-size: 1.3rem;
        color: rgba(255, 255, 255, 0.7);
        text-align: center;
        margin-bottom: 25px;
      }

      .subtitle span {
        background: rgba(46, 204, 113, 0.3);
        padding: 2px 12px;
        border-radius: 4px;
        margin: 0 5px;
      }

      /* Controls */
      .controls {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .btn {
        font-family: "Kalam", cursive;
        font-size: 1.1rem;
        padding: 10px 24px;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .btn:active {
        transform: translateY(1px);
      }

      .btn.primary {
        background: rgba(52, 152, 219, 0.6);
        border-color: #3498db;
      }

      .btn.success {
        background: rgba(46, 204, 113, 0.6);
        border-color: #2ecc71;
      }

      .btn.danger {
        background: rgba(231, 76, 60, 0.6);
        border-color: #e74c3c;
      }

      .btn.warning {
        background: rgba(241, 196, 15, 0.6);
        border-color: #f1c40f;
        color: #2c3e50;
      }

      .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      /* Phase indicator */
      .phase-indicator {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 25px;
      }

      .phase-badge {
        padding: 8px 20px;
        border-radius: 20px;
        font-size: 1rem;
        opacity: 0.4;
        transition: all 0.3s ease;
        border: 2px solid transparent;
      }

      .phase-badge.active {
        opacity: 1;
        transform: scale(1.1);
      }

      .phase-badge.pass1 {
        background: rgba(155, 89, 182, 0.5);
        border-color: #9b59b6;
        color: white;
      }

      .phase-badge.pass2 {
        background: rgba(230, 126, 34, 0.5);
        border-color: #e67e22;
        color: white;
      }

      .phase-badge.pass3 {
        background: rgba(26, 188, 156, 0.5);
        border-color: #1abc9c;
        color: white;
      }

      /* Visualization area */
      .viz-area {
        background: rgba(0, 0, 0, 0.2);
        border: 3px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 25px;
        min-height: 380px;
        position: relative;
        margin-bottom: 25px;
      }

      .viz-title {
        font-family: "Caveat", cursive;
        font-size: 1.6rem;
        color: #74b9ff;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      /* Node container */
      .nodes-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
        position: relative;
        min-height: 280px;
      }

      .list-row {
        display: flex;
        align-items: center;
        gap: 8px;
        min-height: 80px;
        flex-wrap: nowrap;
        padding: 10px 0;
      }

      .row-label {
        font-family: "Caveat", cursive;
        font-size: 1.2rem;
        color: rgba(255, 255, 255, 0.6);
        min-width: 120px;
        text-align: right;
        padding-right: 15px;
      }

      /* Nodes */
      .node {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Fira Code", monospace;
        font-size: 1.2rem;
        font-weight: 600;
        position: relative;
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        flex-shrink: 0;
      }

      .node.original {
        background: linear-gradient(145deg, #74b9ff, #0984e3);
        border: 3px solid #0652dd;
        color: white;
        box-shadow: 0 0 15px rgba(116, 185, 255, 0.5),
          inset 0 -2px 10px rgba(0, 0, 0, 0.2);
      }

      .node.copy {
        background: linear-gradient(145deg, #fd79a8, #e84393);
        border: 3px solid #c44569;
        color: white;
        box-shadow: 0 0 15px rgba(253, 121, 168, 0.5),
          inset 0 -2px 10px rgba(0, 0, 0, 0.2);
      }

      .node.hidden {
        opacity: 0;
        transform: scale(0);
      }

      .node.highlight {
        animation: glow 0.8s ease infinite alternate;
      }

      .node.processing {
        box-shadow: 0 0 0 6px rgba(241, 196, 15, 0.6);
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 15px rgba(241, 196, 15, 0.5),
            0 0 30px rgba(241, 196, 15, 0.3);
        }
        to {
          box-shadow: 0 0 25px rgba(241, 196, 15, 0.8),
            0 0 50px rgba(241, 196, 15, 0.5);
        }
      }

      .node-label {
        position: absolute;
        bottom: -22px;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Kalam", cursive;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.6);
        white-space: nowrap;
      }

      /* Arrows */
      .arrow {
        font-size: 1.4rem;
        color: rgba(255, 255, 255, 0.6);
        flex-shrink: 0;
        transition: all 0.3s ease;
      }

      .arrow.next-orig {
        color: #74b9ff;
      }

      .arrow.next-copy {
        color: #fd79a8;
      }

      .arrow.hidden {
        opacity: 0;
      }

      .null-text {
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.4);
        padding: 5px 10px;
      }

      /* Random pointer SVG */
      .random-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: visible;
      }

      .random-path {
        fill: none;
        stroke: #f39c12;
        stroke-width: 2;
        stroke-dasharray: 6, 4;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .random-path.visible {
        opacity: 1;
      }

      /* Step info */
      .step-info {
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 20px 25px;
        margin-bottom: 20px;
      }

      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }

      .step-number {
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        background: linear-gradient(135deg, #f1c40f, #f39c12);
        color: #2c3e50;
        padding: 4px 18px;
        border-radius: 15px;
        font-weight: 700;
      }

      .step-phase {
        font-family: "Kalam", cursive;
        font-size: 1.1rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .step-description {
        font-family: "Kalam", cursive;
        font-size: 1.2rem;
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.6;
      }

      .step-description code {
        font-family: "Fira Code", monospace;
        background: rgba(255, 255, 255, 0.15);
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 1rem;
        color: #ffeaa7;
      }

      /* Code panel */
      .code-panel {
        background: #0d1117;
        border-radius: 12px;
        padding: 18px;
        margin-bottom: 20px;
        border: 1px solid #30363d;
      }

      .code-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
        padding-bottom: 10px;
        border-bottom: 1px solid #30363d;
      }

      .code-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .code-dot.red {
        background: #ff5f56;
      }
      .code-dot.yellow {
        background: #ffbd2e;
      }
      .code-dot.green {
        background: #27c93f;
      }

      .code-title {
        font-family: "Fira Code", monospace;
        font-size: 0.85rem;
        color: #8b949e;
        margin-left: 10px;
      }

      .code-content {
        font-family: "Fira Code", monospace;
        font-size: 0.8rem;
        color: #c9d1d9;
        line-height: 1.7;
        overflow-x: auto;
      }

      .code-line {
        padding: 1px 0;
        transition: background 0.3s ease;
        white-space: pre;
      }

      .code-line.highlight {
        background: rgba(56, 139, 253, 0.15);
        margin: 0 -18px;
        padding: 1px 18px;
        border-left: 3px solid #58a6ff;
      }

      .code-keyword {
        color: #ff7b72;
      }
      .code-function {
        color: #d2a8ff;
      }
      .code-variable {
        color: #79c0ff;
      }
      .code-comment {
        color: #8b949e;
      }
      .code-property {
        color: #7ee787;
      }

      /* Progress */
      .progress-container {
        margin-bottom: 20px;
      }

      .progress-bar {
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #9b59b6, #e67e22, #1abc9c);
        border-radius: 3px;
        transition: width 0.4s ease;
      }

      .progress-text {
        font-family: "Kalam", cursive;
        font-size: 0.95rem;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 6px;
        text-align: center;
      }

      /* Legend */
      .legend {
        display: flex;
        justify-content: center;
        gap: 25px;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: "Kalam", cursive;
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .legend-dot {
        width: 18px;
        height: 18px;
        border-radius: 50%;
      }

      .legend-dot.original {
        background: #0984e3;
      }
      .legend-dot.copy {
        background: #e84393;
      }

      .legend-line {
        width: 30px;
        height: 3px;
        border-radius: 2px;
      }

      .legend-line.random {
        background: repeating-linear-gradient(
          90deg,
          #f39c12,
          #f39c12 4px,
          transparent 4px,
          transparent 8px
        );
      }

      /* Key insight box */
      .insight-box {
        background: rgba(155, 89, 182, 0.2);
        border: 2px solid rgba(155, 89, 182, 0.5);
        border-radius: 10px;
        padding: 15px 20px;
        margin-top: 15px;
      }

      .insight-title {
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        color: #d4a5ff;
        margin-bottom: 8px;
      }

      .insight-text {
        font-family: "Kalam", cursive;
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.5;
      }

      .insight-text code {
        font-family: "Fira Code", monospace;
        background: rgba(255, 255, 255, 0.1);
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 0.9rem;
      }

      /* Responsive */
      @media (max-width: 900px) {
        .container {
          padding: 20px;
        }

        .title {
          font-size: 2.5rem;
        }

        .node {
          width: 50px;
          height: 50px;
          font-size: 1rem;
        }

        .row-label {
          min-width: 80px;
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="chalkboard">
      <div class="container">
        <h1 class="title chalk-text">Interweaving Approach</h1>
        <p class="subtitle chalk-text">
          Copy List with Random Pointer ‚Ä¢ <span>O(n) Time</span> ‚Ä¢
          <span>O(1) Space</span>
        </p>

        <!-- Phase Indicator -->
        <div class="phase-indicator">
          <div class="phase-badge pass1" id="phase1Badge">
            Pass 1: Interweave
          </div>
          <div class="phase-badge pass2" id="phase2Badge">
            Pass 2: Set Random
          </div>
          <div class="phase-badge pass3" id="phase3Badge">Pass 3: Separate</div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <button class="btn danger" id="resetBtn">‚ü≤ Reset</button>
          <button class="btn" id="prevBtn" disabled>‚Üê Prev</button>
          <button class="btn primary" id="nextBtn">Next ‚Üí</button>
          <button class="btn success" id="autoBtn">‚ñ∂ Auto</button>
          <button class="btn warning" id="skipBtn">‚è≠ Skip to End</button>
        </div>

        <!-- Visualization -->
        <div class="viz-area">
          <div class="viz-title">
            üìã Input: [[7,null], [13,0], [11,4], [10,2], [1,0]]
          </div>

          <div class="nodes-container" id="nodesContainer">
            <!-- Interweaved row (shown during pass 1 & 2) -->
            <div class="list-row" id="interweavedRow">
              <span class="row-label">Interweaved:</span>
              <div
                id="interweavedNodes"
                style="display: flex; align-items: center; gap: 6px"
              ></div>
            </div>

            <!-- Original list (shown after separation) -->
            <div class="list-row" id="originalRow" style="display: none">
              <span class="row-label">Original:</span>
              <div
                id="originalNodes"
                style="display: flex; align-items: center; gap: 8px"
              ></div>
            </div>

            <!-- Copy list (shown after separation) -->
            <div class="list-row" id="copyRow" style="display: none">
              <span class="row-label">Copy:</span>
              <div
                id="copyNodes"
                style="display: flex; align-items: center; gap: 8px"
              ></div>
            </div>
          </div>

          <!-- SVG for random arrows -->
          <svg class="random-svg" id="randomSvg">
            <defs>
              <marker
                id="arrowMarker"
                markerWidth="8"
                markerHeight="6"
                refX="7"
                refY="3"
                orient="auto"
              >
                <polygon points="0 0, 8 3, 0 6" fill="#f39c12" />
              </marker>
            </defs>
          </svg>
        </div>

        <!-- Step Info -->
        <div class="step-info">
          <div class="step-header">
            <span class="step-number" id="stepNumber">Step 0 / 20</span>
            <span class="step-phase" id="stepPhase">Introduction</span>
          </div>
          <div class="step-description" id="stepDescription">
            The interweaving approach achieves O(1) extra space by embedding the
            original ‚Üí copy mapping directly into the list structure. Click
            "Next" to see how!
          </div>
        </div>

        <!-- Key Insight -->
        <div class="insight-box" id="insightBox">
          <div class="insight-title">üí° Key Insight</div>
          <div class="insight-text" id="insightText">
            By placing each copy node immediately after its original, we get
            O(1) access: <code>original.next = copy</code>. This eliminates the
            need for a hash map!
          </div>
        </div>

        <!-- Progress -->
        <div class="progress-container">
          <div class="progress-bar">
            <div
              class="progress-fill"
              id="progressFill"
              style="width: 0%"
            ></div>
          </div>
          <div class="progress-text" id="progressText">Ready to start</div>
        </div>

        <!-- Code Panel -->
        <div class="code-panel">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-title">interweaving-approach.js</span>
          </div>
          <div class="code-content" id="codeContent">
            <div class="code-line" data-line="1">
              <span class="code-keyword">function</span>
              <span class="code-function">copyRandomList</span>(<span
                class="code-variable"
                >head</span
              >) {
            </div>
            <div class="code-line" data-line="2">
              <span class="code-keyword">if</span> (<span class="code-variable"
                >head</span
              >
              === <span class="code-keyword">null</span>)
              <span class="code-keyword">return</span>
              <span class="code-keyword">null</span>;
            </div>
            <div class="code-line" data-line="3"></div>
            <div class="code-line" data-line="4">
              <span class="code-comment"
                >// Pass 1: Create interweaved list</span
              >
            </div>
            <div class="code-line" data-line="5">
              <span class="code-keyword">let</span>
              <span class="code-variable">curr</span> =
              <span class="code-variable">head</span>;
            </div>
            <div class="code-line" data-line="6">
              <span class="code-keyword">while</span> (<span
                class="code-variable"
                >curr</span
              >) {
            </div>
            <div class="code-line" data-line="7">
              <span class="code-keyword">const</span>
              <span class="code-variable">copy</span> =
              <span class="code-keyword">new</span>
              <span class="code-function">Node</span>(<span
                class="code-variable"
                >curr</span
              >.<span class="code-property">val</span>);
            </div>
            <div class="code-line" data-line="8">
              <span class="code-variable">copy</span>.<span
                class="code-property"
                >next</span
              >
              = <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="9">
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >
              = <span class="code-variable">copy</span>;
            </div>
            <div class="code-line" data-line="10">
              <span class="code-variable">curr</span> =
              <span class="code-variable">copy</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="11">}</div>
            <div class="code-line" data-line="12"></div>
            <div class="code-line" data-line="13">
              <span class="code-comment">// Pass 2: Set random pointers</span>
            </div>
            <div class="code-line" data-line="14">
              <span class="code-variable">curr</span> =
              <span class="code-variable">head</span>;
            </div>
            <div class="code-line" data-line="15">
              <span class="code-keyword">while</span> (<span
                class="code-variable"
                >curr</span
              >) {
            </div>
            <div class="code-line" data-line="16">
              <span class="code-keyword">if</span> (<span class="code-variable"
                >curr</span
              >.<span class="code-property">random</span>)
            </div>
            <div class="code-line" data-line="17">
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >.<span class="code-property">random</span> =
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >random</span
              >.<span class="code-property">next</span>;
            </div>
            <div class="code-line" data-line="18">
              <span class="code-variable">curr</span> =
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >.<span class="code-property">next</span>;
            </div>
            <div class="code-line" data-line="19">}</div>
            <div class="code-line" data-line="20"></div>
            <div class="code-line" data-line="21">
              <span class="code-comment">// Pass 3: Separate lists</span>
            </div>
            <div class="code-line" data-line="22">
              <span class="code-keyword">const</span>
              <span class="code-variable">copyHead</span> =
              <span class="code-variable">head</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="23">
              <span class="code-variable">curr</span> =
              <span class="code-variable">head</span>;
            </div>
            <div class="code-line" data-line="24">
              <span class="code-keyword">while</span> (<span
                class="code-variable"
                >curr</span
              >) {
            </div>
            <div class="code-line" data-line="25">
              <span class="code-keyword">const</span>
              <span class="code-variable">copy</span> =
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="26">
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >
              = <span class="code-variable">copy</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="27">
              <span class="code-variable">copy</span>.<span
                class="code-property"
                >next</span
              >
              = <span class="code-variable">copy</span>.<span
                class="code-property"
                >next</span
              >?.<span class="code-property">next</span>;
            </div>
            <div class="code-line" data-line="28">
              <span class="code-variable">curr</span> =
              <span class="code-variable">curr</span>.<span
                class="code-property"
                >next</span
              >;
            </div>
            <div class="code-line" data-line="29">}</div>
            <div class="code-line" data-line="30">
              <span class="code-keyword">return</span>
              <span class="code-variable">copyHead</span>;
            </div>
            <div class="code-line" data-line="31">}</div>
          </div>
        </div>

        <!-- Legend -->
        <div class="legend">
          <div class="legend-item">
            <div class="legend-dot original"></div>
            <span>Original Node</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot copy"></div>
            <span>Copy Node</span>
          </div>
          <div class="legend-item">
            <div class="legend-line random"></div>
            <span>Random Pointer</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Data
      const listData = [
        { val: 7, randomIdx: null },
        { val: 13, randomIdx: 0 },
        { val: 11, randomIdx: 4 },
        { val: 10, randomIdx: 2 },
        { val: 1, randomIdx: 0 },
      ];

      // Steps
      const steps = [
        {
          phase: "Introduction",
          pass: 0,
          description:
            "We'll deep copy a linked list with random pointers using <code>O(1)</code> extra space. The trick: interweave copy nodes between originals!",
          highlightLines: [1, 2],
          insight:
            "By placing each copy node immediately after its original, we get O(1) access: <code>original.next = copy</code>. This eliminates the need for a hash map!",
          action: "init",
        },
        {
          phase: "Pass 1: Setup",
          pass: 1,
          description:
            "Start Pass 1: We'll insert a copy of each node right after the original. Set <code>curr = head</code>.",
          highlightLines: [4, 5],
          insight:
            "After interweaving: A‚ÜíA'‚ÜíB‚ÜíB'‚ÜíC‚ÜíC'. Each copy is immediately accessible via <code>original.next</code>.",
          action: "setupPass1",
        },
        {
          phase: "Pass 1: Interweave",
          pass: 1,
          description:
            "Create <code>7'</code> (copy of node 7). Insert it: <code>7.next = 7'</code>, <code>7'.next = 13</code>. Move <code>curr</code> to 13.",
          highlightLines: [6, 7, 8, 9, 10],
          insight:
            "Now node 7's copy is directly accessible via <code>node7.next</code>!",
          action: "interweave",
          nodeIndex: 0,
        },
        {
          phase: "Pass 1: Interweave",
          pass: 1,
          description:
            "Create <code>13'</code> (copy of node 13). Insert it: <code>13.next = 13'</code>, <code>13'.next = 11</code>. Move <code>curr</code> to 11.",
          highlightLines: [6, 7, 8, 9, 10],
          insight:
            "Pattern: For each original O, its copy O' is at <code>O.next</code>.",
          action: "interweave",
          nodeIndex: 1,
        },
        {
          phase: "Pass 1: Interweave",
          pass: 1,
          description:
            "Create <code>11'</code> (copy of node 11). Insert it: <code>11.next = 11'</code>, <code>11'.next = 10</code>. Move <code>curr</code> to 10.",
          highlightLines: [6, 7, 8, 9, 10],
          insight:
            "The interweaved structure lets us find any copy in O(1) time.",
          action: "interweave",
          nodeIndex: 2,
        },
        {
          phase: "Pass 1: Interweave",
          pass: 1,
          description:
            "Create <code>10'</code> (copy of node 10). Insert it: <code>10.next = 10'</code>, <code>10'.next = 1</code>. Move <code>curr</code> to 1.",
          highlightLines: [6, 7, 8, 9, 10],
          insight: "We're building the mapping into the list structure itself!",
          action: "interweave",
          nodeIndex: 3,
        },
        {
          phase: "Pass 1: Interweave",
          pass: 1,
          description:
            "Create <code>1'</code> (copy of node 1). Insert it: <code>1.next = 1'</code>, <code>1'.next = null</code>. <code>curr</code> becomes null. ‚úì Pass 1 complete!",
          highlightLines: [6, 7, 8, 9, 10, 11],
          insight:
            "All copies created! The list is now: 7‚Üí7'‚Üí13‚Üí13'‚Üí11‚Üí11'‚Üí10‚Üí10'‚Üí1‚Üí1'‚Üínull",
          action: "interweave",
          nodeIndex: 4,
        },
        {
          phase: "Pass 2: Setup",
          pass: 2,
          description:
            "Start Pass 2: Set random pointers for copies. Reset <code>curr = head</code>. The magic: <code>copy.random = original.random.next</code>!",
          highlightLines: [13, 14],
          insight:
            "If original.random points to X, then copy.random should point to X's copy, which is X.next!",
          action: "setupPass2",
        },
        {
          phase: "Pass 2: Set Random",
          pass: 2,
          description:
            "Node <code>7</code>: random is <code>null</code>. So <code>7'.random = null</code>. Move to next original (skip 7'): <code>curr = curr.next.next = 13</code>.",
          highlightLines: [15, 16, 17, 18],
          insight:
            "We skip by 2 each time: curr.next.next jumps over the copy node to the next original.",
          action: "setRandom",
          nodeIndex: 0,
        },
        {
          phase: "Pass 2: Set Random",
          pass: 2,
          description:
            "Node <code>13</code>: random ‚Üí node 7. Set <code>13'.random = 7.next = 7'</code>. Move to next original: <code>curr = 11</code>.",
          highlightLines: [15, 16, 17, 18],
          insight:
            "13.random points to 7, and 7's copy (7') is at 7.next. So 13'.random = 7.next = 7'!",
          action: "setRandom",
          nodeIndex: 1,
        },
        {
          phase: "Pass 2: Set Random",
          pass: 2,
          description:
            "Node <code>11</code>: random ‚Üí node 1. Set <code>11'.random = 1.next = 1'</code>. Move to next original: <code>curr = 10</code>.",
          highlightLines: [15, 16, 17, 18],
          insight:
            "The formula always works: copy.random = original.random.next",
          action: "setRandom",
          nodeIndex: 2,
        },
        {
          phase: "Pass 2: Set Random",
          pass: 2,
          description:
            "Node <code>10</code>: random ‚Üí node 11. Set <code>10'.random = 11.next = 11'</code>. Move to next original: <code>curr = 1</code>.",
          highlightLines: [15, 16, 17, 18],
          insight:
            "Notice: we're connecting COPIES to COPIES. No pointers cross between original and copy lists!",
          action: "setRandom",
          nodeIndex: 3,
        },
        {
          phase: "Pass 2: Set Random",
          pass: 2,
          description:
            "Node <code>1</code>: random ‚Üí node 7. Set <code>1'.random = 7.next = 7'</code>. <code>curr</code> becomes null. ‚úì Pass 2 complete!",
          highlightLines: [15, 16, 17, 18, 19],
          insight:
            "All random pointers set correctly! Now we just need to untangle the two lists.",
          action: "setRandom",
          nodeIndex: 4,
        },
        {
          phase: "Pass 3: Setup",
          pass: 3,
          description:
            "Start Pass 3: Separate the interweaved lists. Save <code>copyHead = head.next = 7'</code>, reset <code>curr = head</code>.",
          highlightLines: [21, 22, 23],
          insight:
            "We need to restore original list AND extract copy list without breaking any pointers!",
          action: "setupPass3",
        },
        {
          phase: "Pass 3: Separate",
          pass: 3,
          description:
            "At node <code>7</code>: Restore <code>7.next = 13</code> (skip 7'). Connect <code>7'.next = 13'</code>. Move to <code>curr = 13</code>.",
          highlightLines: [24, 25, 26, 27, 28],
          insight:
            "We're simultaneously rebuilding both lists by carefully reconnecting pointers.",
          action: "separate",
          nodeIndex: 0,
        },
        {
          phase: "Pass 3: Separate",
          pass: 3,
          description:
            "At node <code>13</code>: Restore <code>13.next = 11</code>. Connect <code>13'.next = 11'</code>. Move to <code>curr = 11</code>.",
          highlightLines: [24, 25, 26, 27, 28],
          insight: "Original list: 7‚Üí13‚Üí... Copy list: 7'‚Üí13'‚Üí...",
          action: "separate",
          nodeIndex: 1,
        },
        {
          phase: "Pass 3: Separate",
          pass: 3,
          description:
            "At node <code>11</code>: Restore <code>11.next = 10</code>. Connect <code>11'.next = 10'</code>. Move to <code>curr = 10</code>.",
          highlightLines: [24, 25, 26, 27, 28],
          insight: "Original list: 7‚Üí13‚Üí11‚Üí... Copy list: 7'‚Üí13'‚Üí11'‚Üí...",
          action: "separate",
          nodeIndex: 2,
        },
        {
          phase: "Pass 3: Separate",
          pass: 3,
          description:
            "At node <code>10</code>: Restore <code>10.next = 1</code>. Connect <code>10'.next = 1'</code>. Move to <code>curr = 1</code>.",
          highlightLines: [24, 25, 26, 27, 28],
          insight: "Almost done! Just one more node to process.",
          action: "separate",
          nodeIndex: 3,
        },
        {
          phase: "Pass 3: Separate",
          pass: 3,
          description:
            "At node <code>1</code>: Restore <code>1.next = null</code>. Set <code>1'.next = null</code>. <code>curr</code> becomes null. ‚úì Pass 3 complete!",
          highlightLines: [24, 25, 26, 27, 28, 29],
          insight: "Both lists are now completely separated and independent!",
          action: "separate",
          nodeIndex: 4,
        },
        {
          phase: "‚úÖ Complete!",
          pass: 3,
          description:
            "Return <code>copyHead</code> (which is <code>7'</code>). Deep copy created in <code>O(n)</code> time and <code>O(1)</code> extra space!",
          highlightLines: [30],
          insight:
            "The copy list has all correct next and random pointers, with NO references to the original list!",
          action: "complete",
        },
      ];

      // State
      let currentStep = 0;
      let autoPlayInterval = null;
      let interweavedState = [];
      let randomPointersSet = [];
      let separationProgress = 0;

      // DOM elements
      const nextBtn = document.getElementById("nextBtn");
      const prevBtn = document.getElementById("prevBtn");
      const resetBtn = document.getElementById("resetBtn");
      const autoBtn = document.getElementById("autoBtn");
      const skipBtn = document.getElementById("skipBtn");
      const stepNumber = document.getElementById("stepNumber");
      const stepPhase = document.getElementById("stepPhase");
      const stepDescription = document.getElementById("stepDescription");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const insightText = document.getElementById("insightText");
      const phase1Badge = document.getElementById("phase1Badge");
      const phase2Badge = document.getElementById("phase2Badge");
      const phase3Badge = document.getElementById("phase3Badge");
      const interweavedRow = document.getElementById("interweavedRow");
      const originalRow = document.getElementById("originalRow");
      const copyRow = document.getElementById("copyRow");
      const interweavedNodes = document.getElementById("interweavedNodes");
      const originalNodes = document.getElementById("originalNodes");
      const copyNodes = document.getElementById("copyNodes");
      const randomSvg = document.getElementById("randomSvg");

      // Initialize
      function init() {
        renderInitialState();
        updateUI();
      }

      function renderInitialState() {
        interweavedNodes.innerHTML = "";

        // Show only original nodes initially
        listData.forEach((node, idx) => {
          const nodeEl = createNodeElement(
            node.val,
            "original",
            `orig-${idx}`,
            idx
          );
          interweavedNodes.appendChild(nodeEl);

          if (idx < listData.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow next-orig";
            arrow.textContent = "‚Üí";
            arrow.id = `arrow-orig-${idx}`;
            interweavedNodes.appendChild(arrow);
          }
        });

        const nullText = document.createElement("span");
        nullText.className = "null-text";
        nullText.textContent = "‚Üí null";
        interweavedNodes.appendChild(nullText);
      }

      function createNodeElement(val, type, id, idx) {
        const node = document.createElement("div");
        node.className = `node ${type}`;
        node.id = id;
        node.textContent = type === "copy" ? `${val}'` : val;

        const label = document.createElement("span");
        label.className = "node-label";
        label.textContent = type === "copy" ? `copy[${idx}]` : `[${idx}]`;
        node.appendChild(label);

        return node;
      }

      function updateUI() {
        const step = steps[currentStep];

        // Update step info
        stepNumber.textContent = `Step ${currentStep} / ${steps.length - 1}`;
        stepPhase.textContent = step.phase;
        stepDescription.innerHTML = step.description;
        insightText.innerHTML = step.insight;

        // Update phase badges
        phase1Badge.classList.toggle("active", step.pass === 1);
        phase2Badge.classList.toggle("active", step.pass === 2);
        phase3Badge.classList.toggle("active", step.pass === 3);

        // Update progress
        const progress = (currentStep / (steps.length - 1)) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent =
          currentStep === steps.length - 1
            ? "üéâ Complete!"
            : `${Math.round(progress)}% complete`;

        // Update code highlighting
        document.querySelectorAll(".code-line").forEach((line) => {
          line.classList.remove("highlight");
        });
        step.highlightLines.forEach((lineNum) => {
          const line = document.querySelector(
            `.code-line[data-line="${lineNum}"]`
          );
          if (line) line.classList.add("highlight");
        });

        // Update buttons
        prevBtn.disabled = currentStep === 0;
        nextBtn.disabled = currentStep === steps.length - 1;

        // Execute action
        executeAction(step);
      }

      function executeAction(step) {
        // Clear highlights
        document
          .querySelectorAll(".node")
          .forEach((n) => n.classList.remove("highlight", "processing"));

        switch (step.action) {
          case "init":
            resetVisualization();
            break;

          case "setupPass1":
            document.getElementById("orig-0")?.classList.add("highlight");
            break;

          case "interweave":
            performInterweave(step.nodeIndex);
            break;

          case "setupPass2":
            // Show full interweaved state
            document.getElementById("orig-0")?.classList.add("highlight");
            break;

          case "setRandom":
            performSetRandom(step.nodeIndex);
            break;

          case "setupPass3":
            document.getElementById("orig-0")?.classList.add("highlight");
            document.getElementById("copy-0")?.classList.add("highlight");
            break;

          case "separate":
            performSeparation(step.nodeIndex);
            break;

          case "complete":
            showFinalState();
            break;
        }
      }

      function performInterweave(nodeIndex) {
        // Rebuild interweaved list up to this point
        interweavedNodes.innerHTML = "";

        for (let i = 0; i < listData.length; i++) {
          // Add original node
          const origNode = createNodeElement(
            listData[i].val,
            "original",
            `orig-${i}`,
            i
          );
          if (i === nodeIndex) origNode.classList.add("processing");
          interweavedNodes.appendChild(origNode);

          // Add copy if we've reached this point
          if (i <= nodeIndex) {
            const arrowToCopy = document.createElement("span");
            arrowToCopy.className = "arrow next-orig";
            arrowToCopy.textContent = "‚Üí";
            interweavedNodes.appendChild(arrowToCopy);

            const copyNode = createNodeElement(
              listData[i].val,
              "copy",
              `copy-${i}`,
              i
            );
            if (i === nodeIndex) copyNode.classList.add("highlight");
            interweavedNodes.appendChild(copyNode);

            if (i < listData.length - 1) {
              const arrowToNext = document.createElement("span");
              arrowToNext.className = "arrow next-copy";
              arrowToNext.textContent = "‚Üí";
              interweavedNodes.appendChild(arrowToNext);
            }
          } else {
            if (i < listData.length - 1) {
              const arrow = document.createElement("span");
              arrow.className = "arrow next-orig";
              arrow.textContent = "‚Üí";
              interweavedNodes.appendChild(arrow);
            }
          }
        }

        const nullText = document.createElement("span");
        nullText.className = "null-text";
        nullText.textContent = "‚Üí null";
        interweavedNodes.appendChild(nullText);

        interweavedState = Array(nodeIndex + 1).fill(true);
      }

      function performSetRandom(nodeIndex) {
        // Show full interweaved state
        interweavedNodes.innerHTML = "";

        for (let i = 0; i < listData.length; i++) {
          const origNode = createNodeElement(
            listData[i].val,
            "original",
            `orig-${i}`,
            i
          );
          if (i === nodeIndex) origNode.classList.add("processing");
          interweavedNodes.appendChild(origNode);

          const arrowToCopy = document.createElement("span");
          arrowToCopy.className = "arrow next-orig";
          arrowToCopy.textContent = "‚Üí";
          interweavedNodes.appendChild(arrowToCopy);

          const copyNode = createNodeElement(
            listData[i].val,
            "copy",
            `copy-${i}`,
            i
          );
          if (i === nodeIndex) copyNode.classList.add("highlight");
          interweavedNodes.appendChild(copyNode);

          if (i < listData.length - 1) {
            const arrowToNext = document.createElement("span");
            arrowToNext.className = "arrow next-copy";
            arrowToNext.textContent = "‚Üí";
            interweavedNodes.appendChild(arrowToNext);
          }
        }

        const nullText = document.createElement("span");
        nullText.className = "null-text";
        nullText.textContent = "‚Üí null";
        interweavedNodes.appendChild(nullText);

        // Track random pointers set
        if (!randomPointersSet.includes(nodeIndex)) {
          randomPointersSet.push(nodeIndex);
        }

        // Draw random arrows
        setTimeout(() => drawRandomArrows(), 100);
      }

      function drawRandomArrows() {
        // Clear existing
        randomSvg.querySelectorAll(".random-path").forEach((p) => p.remove());

        randomPointersSet.forEach((idx) => {
          const randomTarget = listData[idx].randomIdx;
          if (randomTarget !== null) {
            const fromNode = document.getElementById(`copy-${idx}`);
            const toNode = document.getElementById(`copy-${randomTarget}`);

            if (fromNode && toNode) {
              const fromRect = fromNode.getBoundingClientRect();
              const toRect = toNode.getBoundingClientRect();
              const svgRect = randomSvg.getBoundingClientRect();

              const fromX = fromRect.left - svgRect.left + fromRect.width / 2;
              const fromY = fromRect.top - svgRect.top + fromRect.height;
              const toX = toRect.left - svgRect.left + toRect.width / 2;
              const toY = toRect.top - svgRect.top + toRect.height;

              const curveHeight = 35 + (idx % 3) * 15;
              const midX = (fromX + toX) / 2;
              const midY = fromY + curveHeight;

              const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
              path.setAttribute(
                "d",
                `M ${fromX} ${
                  fromY + 5
                } Q ${fromX} ${midY}, ${midX} ${midY} T ${toX} ${toY + 5}`
              );
              path.setAttribute("class", "random-path visible");
              path.setAttribute("marker-end", "url(#arrowMarker)");
              randomSvg.appendChild(path);
            }
          }
        });
      }

      function performSeparation(nodeIndex) {
        if (nodeIndex === 0) {
          // First separation step - switch to two-row view
          interweavedRow.style.display = "none";
          originalRow.style.display = "flex";
          copyRow.style.display = "flex";
        }

        // Build original list up to separation point
        originalNodes.innerHTML = "";
        for (let i = 0; i < listData.length; i++) {
          const node = createNodeElement(
            listData[i].val,
            "original",
            `sep-orig-${i}`,
            i
          );
          if (i === nodeIndex) node.classList.add("processing");
          originalNodes.appendChild(node);

          if (i <= nodeIndex) {
            // These are separated
            if (i < listData.length - 1) {
              const arrow = document.createElement("span");
              arrow.className = "arrow next-orig";
              arrow.textContent = "‚Üí";
              originalNodes.appendChild(arrow);
            } else {
              const nullText = document.createElement("span");
              nullText.className = "null-text";
              nullText.textContent = "‚Üí null";
              originalNodes.appendChild(nullText);
            }
          } else {
            // Still interweaved (show with copy)
            const arrowToCopy = document.createElement("span");
            arrowToCopy.className = "arrow";
            arrowToCopy.textContent = "‚Üí";
            arrowToCopy.style.color = "rgba(255,255,255,0.3)";
            originalNodes.appendChild(arrowToCopy);

            const copyPlaceholder = document.createElement("span");
            copyPlaceholder.className = "null-text";
            copyPlaceholder.textContent = `${listData[i].val}'`;
            copyPlaceholder.style.color = "#e84393";
            copyPlaceholder.style.opacity = "0.5";
            originalNodes.appendChild(copyPlaceholder);

            if (i < listData.length - 1) {
              const arrow = document.createElement("span");
              arrow.className = "arrow";
              arrow.textContent = "‚Üí";
              arrow.style.opacity = "0.3";
              originalNodes.appendChild(arrow);
            }
          }
        }

        // Build copy list up to separation point
        copyNodes.innerHTML = "";
        for (let i = 0; i <= nodeIndex; i++) {
          const node = createNodeElement(
            listData[i].val,
            "copy",
            `sep-copy-${i}`,
            i
          );
          if (i === nodeIndex) node.classList.add("highlight");
          copyNodes.appendChild(node);

          if (i < nodeIndex) {
            const arrow = document.createElement("span");
            arrow.className = "arrow next-copy";
            arrow.textContent = "‚Üí";
            copyNodes.appendChild(arrow);
          } else if (i === nodeIndex) {
            if (nodeIndex < listData.length - 1) {
              const arrow = document.createElement("span");
              arrow.className = "arrow next-copy";
              arrow.textContent = "‚Üí";
              arrow.style.opacity = "0.5";
              copyNodes.appendChild(arrow);
            } else {
              const nullText = document.createElement("span");
              nullText.className = "null-text";
              nullText.textContent = "‚Üí null";
              copyNodes.appendChild(nullText);
            }
          }
        }

        // Draw random arrows for separated copy list
        randomSvg.querySelectorAll(".random-path").forEach((p) => p.remove());
        setTimeout(() => {
          for (let i = 0; i <= nodeIndex; i++) {
            const randomTarget = listData[i].randomIdx;
            if (randomTarget !== null && randomTarget <= nodeIndex) {
              const fromNode = document.getElementById(`sep-copy-${i}`);
              const toNode = document.getElementById(
                `sep-copy-${randomTarget}`
              );

              if (fromNode && toNode) {
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const svgRect = randomSvg.getBoundingClientRect();

                const fromX = fromRect.left - svgRect.left + fromRect.width / 2;
                const fromY = fromRect.top - svgRect.top + fromRect.height;
                const toX = toRect.left - svgRect.left + toRect.width / 2;
                const toY = toRect.top - svgRect.top + toRect.height;

                const curveHeight = 30 + (i % 2) * 15;
                const midX = (fromX + toX) / 2;
                const midY = fromY + curveHeight;

                const path = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "path"
                );
                path.setAttribute(
                  "d",
                  `M ${fromX} ${
                    fromY + 5
                  } Q ${fromX} ${midY}, ${midX} ${midY} T ${toX} ${toY + 5}`
                );
                path.setAttribute("class", "random-path visible");
                path.setAttribute("marker-end", "url(#arrowMarker)");
                randomSvg.appendChild(path);
              }
            }
          }
        }, 100);

        separationProgress = nodeIndex + 1;
      }

      function showFinalState() {
        interweavedRow.style.display = "none";
        originalRow.style.display = "flex";
        copyRow.style.display = "flex";

        // Complete original list
        originalNodes.innerHTML = "";
        listData.forEach((node, i) => {
          const nodeEl = createNodeElement(
            node.val,
            "original",
            `final-orig-${i}`,
            i
          );
          originalNodes.appendChild(nodeEl);

          if (i < listData.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow next-orig";
            arrow.textContent = "‚Üí";
            originalNodes.appendChild(arrow);
          }
        });
        let nullText = document.createElement("span");
        nullText.className = "null-text";
        nullText.textContent = "‚Üí null";
        originalNodes.appendChild(nullText);

        // Complete copy list with highlight
        copyNodes.innerHTML = "";
        listData.forEach((node, i) => {
          const nodeEl = createNodeElement(
            node.val,
            "copy",
            `final-copy-${i}`,
            i
          );
          nodeEl.classList.add("highlight");
          copyNodes.appendChild(nodeEl);

          if (i < listData.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "arrow next-copy";
            arrow.textContent = "‚Üí";
            copyNodes.appendChild(arrow);
          }
        });
        nullText = document.createElement("span");
        nullText.className = "null-text";
        nullText.textContent = "‚Üí null";
        copyNodes.appendChild(nullText);

        // Draw all random arrows for copy list
        setTimeout(() => {
          randomSvg.querySelectorAll(".random-path").forEach((p) => p.remove());
          listData.forEach((node, i) => {
            if (node.randomIdx !== null) {
              const fromNode = document.getElementById(`final-copy-${i}`);
              const toNode = document.getElementById(
                `final-copy-${node.randomIdx}`
              );

              if (fromNode && toNode) {
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const svgRect = randomSvg.getBoundingClientRect();

                const fromX = fromRect.left - svgRect.left + fromRect.width / 2;
                const fromY = fromRect.top - svgRect.top + fromRect.height;
                const toX = toRect.left - svgRect.left + toRect.width / 2;
                const toY = toRect.top - svgRect.top + toRect.height;

                const curveHeight = 30 + (i % 3) * 12;
                const midX = (fromX + toX) / 2;
                const midY = fromY + curveHeight;

                const path = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "path"
                );
                path.setAttribute(
                  "d",
                  `M ${fromX} ${
                    fromY + 5
                  } Q ${fromX} ${midY}, ${midX} ${midY} T ${toX} ${toY + 5}`
                );
                path.setAttribute("class", "random-path visible");
                path.setAttribute("marker-end", "url(#arrowMarker)");
                randomSvg.appendChild(path);
              }
            }
          });
        }, 100);
      }

      function resetVisualization() {
        interweavedState = [];
        randomPointersSet = [];
        separationProgress = 0;

        interweavedRow.style.display = "flex";
        originalRow.style.display = "none";
        copyRow.style.display = "none";

        randomSvg.querySelectorAll(".random-path").forEach((p) => p.remove());

        renderInitialState();
      }

      function rebuildToStep(targetStep) {
        resetVisualization();

        for (let i = 0; i <= targetStep; i++) {
          const step = steps[i];
          switch (step.action) {
            case "interweave":
              interweavedState.push(step.nodeIndex);
              break;
            case "setRandom":
              if (!randomPointersSet.includes(step.nodeIndex)) {
                randomPointersSet.push(step.nodeIndex);
              }
              break;
            case "separate":
              separationProgress = step.nodeIndex + 1;
              break;
          }
        }
      }

      // Event listeners
      nextBtn.addEventListener("click", () => {
        if (currentStep < steps.length - 1) {
          currentStep++;
          updateUI();
        }
      });

      prevBtn.addEventListener("click", () => {
        if (currentStep > 0) {
          currentStep--;
          rebuildToStep(currentStep);
          updateUI();
        }
      });

      resetBtn.addEventListener("click", () => {
        stopAutoPlay();
        currentStep = 0;
        resetVisualization();
        updateUI();
      });

      autoBtn.addEventListener("click", () => {
        if (autoPlayInterval) {
          stopAutoPlay();
        } else {
          startAutoPlay();
        }
      });

      skipBtn.addEventListener("click", () => {
        stopAutoPlay();
        currentStep = steps.length - 1;
        rebuildToStep(currentStep);
        updateUI();
      });

      function startAutoPlay() {
        autoBtn.textContent = "‚è∏ Pause";
        autoBtn.classList.remove("success");
        autoBtn.classList.add("danger");

        autoPlayInterval = setInterval(() => {
          if (currentStep < steps.length - 1) {
            currentStep++;
            updateUI();
          } else {
            stopAutoPlay();
          }
        }, 2200);
      }

      function stopAutoPlay() {
        if (autoPlayInterval) {
          clearInterval(autoPlayInterval);
          autoPlayInterval = null;
        }
        autoBtn.textContent = "‚ñ∂ Auto";
        autoBtn.classList.remove("danger");
        autoBtn.classList.add("success");
      }

      // Keyboard navigation
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowRight" && currentStep < steps.length - 1) {
          currentStep++;
          updateUI();
        } else if (e.key === "ArrowLeft" && currentStep > 0) {
          currentStep--;
          rebuildToStep(currentStep);
          updateUI();
        } else if (e.key === " ") {
          e.preventDefault();
          autoBtn.click();
        } else if (e.key === "r" || e.key === "R") {
          resetBtn.click();
        }
      });

      // Handle resize
      window.addEventListener("resize", () => {
        if (randomPointersSet.length > 0 || separationProgress > 0) {
          setTimeout(() => {
            const step = steps[currentStep];
            if (step.action === "setRandom") {
              drawRandomArrows();
            } else if (
              step.action === "separate" ||
              step.action === "complete"
            ) {
              // Redraw for separated view
              executeAction(step);
            }
          }, 100);
        }
      });

      // Initialize
      init();
    </script>
  </body>
</html>
