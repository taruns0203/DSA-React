<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merge K Sorted Lists - Min-Heap (Optimal) Approach</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Caveat:wght@400;600;700&family=Patrick+Hand&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Patrick Hand", cursive;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .whiteboard {
        background: linear-gradient(to bottom, #2c3e50 0%, #1a252f 100%);
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5),
          inset 0 0 100px rgba(255, 255, 255, 0.02);
        max-width: 1400px;
        margin: 0 auto;
        padding: 30px;
        position: relative;
        border: 8px solid #34495e;
      }

      h1 {
        font-family: "Caveat", cursive;
        font-size: 2.8rem;
        color: #f39c12;
        text-align: center;
        margin-bottom: 10px;
        text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
      }

      .subtitle {
        text-align: center;
        font-size: 1.4rem;
        color: #bdc3c7;
        margin-bottom: 25px;
      }

      .optimal-badge {
        display: inline-block;
        background: linear-gradient(135deg, #f39c12 0%, #e74c3c 100%);
        color: #fff;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 1rem;
        margin-left: 10px;
        vertical-align: middle;
      }

      .phase-indicator {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .phase-badge {
        padding: 10px 20px;
        border-radius: 25px;
        font-size: 1.05rem;
        border: 2px solid #7f8c8d;
        color: #95a5a6;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.05);
      }

      .phase-badge.active {
        border-color: #f39c12;
        background: rgba(243, 156, 18, 0.2);
        color: #f39c12;
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
      }

      .phase-badge.completed {
        border-color: #27ae60;
        background: rgba(39, 174, 96, 0.2);
        color: #2ecc71;
      }

      .step-counter {
        text-align: center;
        font-family: "Caveat", cursive;
        font-size: 1.5rem;
        color: #bdc3c7;
        margin-bottom: 15px;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 28px;
        font-family: "Patrick Hand", cursive;
        font-size: 1.2rem;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #fff;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .btn-primary {
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      }

      .btn-success {
        background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
      }

      .btn-warning {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
      }

      .btn-danger {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .speed-control {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
      }

      .speed-label {
        font-size: 1.1rem;
        color: #bdc3c7;
      }

      .speed-slider {
        width: 150px;
        height: 8px;
        -webkit-appearance: none;
        background: #34495e;
        border-radius: 4px;
        outline: none;
      }

      .speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        border-radius: 50%;
        cursor: pointer;
      }

      .explanation-box {
        background: rgba(52, 152, 219, 0.1);
        border: 2px solid #3498db;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        min-height: 100px;
      }

      .explanation-title {
        font-family: "Caveat", cursive;
        font-size: 1.4rem;
        color: #3498db;
        margin-bottom: 10px;
      }

      .explanation-text {
        font-size: 1.15rem;
        color: #ecf0f1;
        line-height: 1.6;
      }

      .code-display {
        font-family: "Courier New", monospace;
        background: #1a252f;
        color: #2ecc71;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 1rem;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
        margin-bottom: 25px;
      }

      @media (max-width: 1000px) {
        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      .section {
        background: rgba(255, 255, 255, 0.03);
        border: 2px solid #34495e;
        border-radius: 12px;
        padding: 20px;
      }

      .section-title {
        font-family: "Caveat", cursive;
        font-size: 1.5rem;
        color: #f39c12;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #34495e;
      }

      /* Input Lists */
      .input-lists {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .list-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .list-label {
        font-family: "Caveat", cursive;
        font-size: 1.2rem;
        color: #9b59b6;
        min-width: 60px;
      }

      .linked-list {
        display: flex;
        align-items: center;
        gap: 5px;
        flex-wrap: wrap;
      }

      .node {
        width: 44px;
        height: 44px;
        border: 3px solid #9b59b6;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        font-weight: bold;
        color: #fff;
        background: rgba(155, 89, 182, 0.3);
        transition: all 0.3s ease;
        position: relative;
      }

      .node.head-pointer {
        border-color: #f39c12;
        background: rgba(243, 156, 18, 0.4);
        box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        transform: scale(1.1);
      }

      .node.in-heap {
        border-color: #e74c3c;
        background: rgba(231, 76, 60, 0.4);
      }

      .node.extracted {
        opacity: 0.3;
        transform: scale(0.8);
      }

      .node-arrow {
        color: #9b59b6;
        font-size: 1.3rem;
      }

      .null-text {
        font-size: 0.95rem;
        color: #7f8c8d;
        font-style: italic;
      }

      /* Heap visualization */
      .heap-container {
        min-height: 200px;
      }

      .heap-tree {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .heap-level {
        display: flex;
        justify-content: center;
        gap: 30px;
      }

      .heap-node {
        width: 55px;
        height: 55px;
        border: 3px solid #e74c3c;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        font-weight: bold;
        color: #fff;
        background: rgba(231, 76, 60, 0.3);
        transition: all 0.3s ease;
        position: relative;
      }

      .heap-node.min-node {
        border-color: #f39c12;
        background: rgba(243, 156, 18, 0.5);
        box-shadow: 0 0 25px rgba(243, 156, 18, 0.6);
        transform: scale(1.15);
      }

      .heap-node.extracting {
        animation: extractPulse 0.5s ease;
      }

      @keyframes extractPulse {
        0% {
          transform: scale(1.15);
        }
        50% {
          transform: scale(1.4);
          opacity: 0.5;
        }
        100% {
          transform: scale(0);
          opacity: 0;
        }
      }

      .heap-node-label {
        position: absolute;
        bottom: -22px;
        font-size: 0.8rem;
        color: #95a5a6;
        white-space: nowrap;
      }

      .heap-empty {
        color: #7f8c8d;
        font-style: italic;
        font-size: 1.1rem;
        text-align: center;
        padding: 40px;
      }

      .heap-array {
        margin-top: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
      }

      .heap-array-title {
        font-size: 1rem;
        color: #95a5a6;
        margin-bottom: 10px;
      }

      .heap-array-values {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .heap-array-val {
        padding: 5px 12px;
        background: rgba(231, 76, 60, 0.3);
        border: 2px solid #e74c3c;
        border-radius: 6px;
        color: #fff;
        font-size: 1.1rem;
      }

      .heap-array-val.min {
        background: rgba(243, 156, 18, 0.5);
        border-color: #f39c12;
      }

      /* Result section */
      .result-section {
        grid-column: 1 / -1;
      }

      .result-list {
        display: flex;
        align-items: center;
        gap: 5px;
        min-height: 60px;
        flex-wrap: wrap;
        padding: 15px;
        background: rgba(39, 174, 96, 0.1);
        border: 2px solid #27ae60;
        border-radius: 10px;
      }

      .result-node {
        width: 48px;
        height: 48px;
        border: 3px solid #27ae60;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        font-weight: bold;
        color: #fff;
        background: rgba(39, 174, 96, 0.4);
        animation: nodeAppear 0.4s ease;
      }

      @keyframes nodeAppear {
        0% {
          transform: scale(0) translateY(-20px);
          opacity: 0;
        }
        60% {
          transform: scale(1.2) translateY(0);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .result-arrow {
        color: #27ae60;
        font-size: 1.4rem;
      }

      .empty-placeholder {
        color: #7f8c8d;
        font-style: italic;
        font-size: 1.1rem;
      }

      /* Operation log */
      .operation-log {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 15px;
        margin-top: 15px;
        max-height: 150px;
        overflow-y: auto;
      }

      .log-title {
        font-size: 1.1rem;
        color: #f39c12;
        margin-bottom: 10px;
      }

      .log-entry {
        font-size: 1rem;
        color: #bdc3c7;
        padding: 5px 0;
        border-bottom: 1px solid #34495e;
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-extract {
        color: #e74c3c;
      }

      .log-insert {
        color: #2ecc71;
      }

      .complexity-box {
        background: rgba(243, 156, 18, 0.1);
        border: 2px solid #f39c12;
        border-radius: 12px;
        padding: 15px;
        margin-top: 20px;
      }

      .complexity-title {
        font-family: "Caveat", cursive;
        font-size: 1.3rem;
        color: #f39c12;
        margin-bottom: 8px;
      }

      .complexity-item {
        font-size: 1.1rem;
        color: #f5d76e;
        margin: 5px 0;
      }

      /* Heap connections (SVG) */
      .heap-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .heap-wrapper {
        position: relative;
        min-height: 180px;
      }
    </style>
  </head>
  <body>
    <div class="whiteboard">
      <h1>
        ‚ö° Merge K Sorted Lists <span class="optimal-badge">OPTIMAL</span>
      </h1>
      <p class="subtitle">
        Min-Heap (Priority Queue) Approach - Interactive Visualization
      </p>

      <div class="phase-indicator">
        <div class="phase-badge" id="phase0">üì• Initialize Heap</div>
        <div class="phase-badge" id="phase1">üîÑ Extract & Insert</div>
        <div class="phase-badge" id="phase2">‚úÖ Complete</div>
      </div>

      <div class="step-counter" id="stepCounter">Ready to start!</div>

      <div class="controls">
        <button class="btn btn-primary" id="stepBtn" onclick="nextStep()">
          ‚ñ∂ Step
        </button>
        <button class="btn btn-success" id="autoBtn" onclick="toggleAuto()">
          ‚èµ Auto Play
        </button>
        <button class="btn btn-danger" onclick="reset()">‚Ü∫ Reset</button>
      </div>

      <div class="speed-control">
        <span class="speed-label">Speed:</span>
        <input
          type="range"
          class="speed-slider"
          id="speedSlider"
          min="300"
          max="1500"
          value="600"
        />
        <span class="speed-label" id="speedValue">Medium</span>
      </div>

      <div class="explanation-box">
        <div class="explanation-title">üí° Current Action:</div>
        <div class="explanation-text" id="explanation">
          Click <strong>Step</strong> to begin, or <strong>Auto Play</strong> to
          watch automatically. <br /><br />
          <strong>Input:</strong> lists = [[1,4,5], [1,3,4], [2,6]]<br />
          <strong>Strategy:</strong> Use a min-heap to always find the smallest
          element among all list heads in O(log k) time.
        </div>
      </div>

      <div class="main-grid">
        <div class="section">
          <div class="section-title">üìã Input Lists (with head pointers)</div>
          <div class="input-lists" id="inputLists"></div>

          <div class="operation-log" id="operationLog">
            <div class="log-title">üìù Operation Log</div>
            <div id="logEntries">
              <div class="log-entry">Waiting to start...</div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">üèîÔ∏è Min-Heap (Priority Queue)</div>
          <div class="heap-container">
            <div class="heap-wrapper" id="heapWrapper">
              <div class="heap-tree" id="heapTree">
                <div class="heap-empty">
                  Heap is empty - will initialize with list heads
                </div>
              </div>
            </div>
            <div class="heap-array">
              <div class="heap-array-title">Heap Array Representation:</div>
              <div class="heap-array-values" id="heapArray">
                <span class="empty-placeholder">[ ]</span>
              </div>
            </div>
          </div>
        </div>

        <div class="section result-section">
          <div class="section-title">‚úÖ Result: Merged Sorted List</div>
          <div class="result-list" id="resultList">
            <span class="empty-placeholder"
              >Will build as we extract from heap...</span
            >
          </div>
        </div>
      </div>

      <div class="complexity-box">
        <div class="complexity-title">
          üìä Complexity Analysis - Why This is Optimal
        </div>
        <div class="complexity-item">
          ‚è±Ô∏è <strong>Time:</strong> O(N log k) ‚Äî Each of N nodes enters/exits
          heap once, each operation O(log k)
        </div>
        <div class="complexity-item">
          üíæ <strong>Space:</strong> O(k) ‚Äî Heap stores at most k nodes (one
          from each list)
        </div>
        <div class="complexity-item">
          üéØ <strong>Key Insight:</strong> Heap gives us O(log k) access to
          global minimum vs O(k) brute scan
        </div>
      </div>
    </div>

    <script>
      // Input data - using objects to track list and position
      const inputLists = [
        [1, 4, 5],
        [1, 3, 4],
        [2, 6],
      ];

      // State
      let currentPhase = "init";
      let totalSteps = 0;

      // Pointers for each list (index of current head)
      let listPointers = [0, 0, 0];

      // Min heap - stores {val, listIdx, nodeIdx}
      let heap = [];

      // Result
      let result = [];

      // Log entries
      let logEntries = [];

      let isAutoPlaying = false;
      let autoInterval = null;

      // Speed
      const speedSlider = document.getElementById("speedSlider");
      const speedValue = document.getElementById("speedValue");

      speedSlider.addEventListener("input", () => {
        const val = speedSlider.value;
        if (val < 600) speedValue.textContent = "Fast";
        else if (val < 1000) speedValue.textContent = "Medium";
        else speedValue.textContent = "Slow";
      });

      function getSpeed() {
        return parseInt(speedSlider.value);
      }

      // Heap operations
      function heapPush(item) {
        heap.push(item);
        bubbleUp(heap.length - 1);
      }

      function heapPop() {
        if (heap.length === 0) return null;
        const min = heap[0];
        const last = heap.pop();
        if (heap.length > 0) {
          heap[0] = last;
          bubbleDown(0);
        }
        return min;
      }

      function bubbleUp(index) {
        while (index > 0) {
          const parentIdx = Math.floor((index - 1) / 2);
          if (heap[index].val >= heap[parentIdx].val) break;
          [heap[index], heap[parentIdx]] = [heap[parentIdx], heap[index]];
          index = parentIdx;
        }
      }

      function bubbleDown(index) {
        const length = heap.length;
        while (true) {
          const left = 2 * index + 1;
          const right = 2 * index + 2;
          let smallest = index;

          if (left < length && heap[left].val < heap[smallest].val) {
            smallest = left;
          }
          if (right < length && heap[right].val < heap[smallest].val) {
            smallest = right;
          }
          if (smallest === index) break;

          [heap[index], heap[smallest]] = [heap[smallest], heap[index]];
          index = smallest;
        }
      }

      function initDisplay() {
        const container = document.getElementById("inputLists");
        container.innerHTML = "";

        inputLists.forEach((list, idx) => {
          const row = document.createElement("div");
          row.className = "list-row";
          row.id = `list-row-${idx}`;

          const label = document.createElement("span");
          label.className = "list-label";
          label.textContent = `L${idx}:`;
          row.appendChild(label);

          const linkedList = document.createElement("div");
          linkedList.className = "linked-list";
          linkedList.id = `linked-list-${idx}`;

          list.forEach((val, nodeIdx) => {
            const node = document.createElement("div");
            node.className = "node";
            node.id = `node-${idx}-${nodeIdx}`;
            node.textContent = val;
            linkedList.appendChild(node);

            if (nodeIdx < list.length - 1) {
              const arrow = document.createElement("span");
              arrow.className = "node-arrow";
              arrow.textContent = "‚Üí";
              linkedList.appendChild(arrow);
            }
          });

          const nullText = document.createElement("span");
          nullText.className = "null-text";
          nullText.textContent = " ‚Üí null";
          linkedList.appendChild(nullText);

          row.appendChild(linkedList);
          container.appendChild(row);
        });
      }

      function updateInputDisplay() {
        inputLists.forEach((list, listIdx) => {
          list.forEach((val, nodeIdx) => {
            const node = document.getElementById(`node-${listIdx}-${nodeIdx}`);
            node.className = "node";

            // Check if this node has been extracted
            if (nodeIdx < listPointers[listIdx]) {
              node.classList.add("extracted");
            }
            // Check if this is current head and in heap
            else if (nodeIdx === listPointers[listIdx]) {
              const inHeap = heap.some(
                (h) => h.listIdx === listIdx && h.nodeIdx === nodeIdx
              );
              if (inHeap) {
                node.classList.add("head-pointer");
                node.classList.add("in-heap");
              }
            }
          });
        });
      }

      function renderHeap() {
        const heapTree = document.getElementById("heapTree");
        const heapArray = document.getElementById("heapArray");

        if (heap.length === 0) {
          heapTree.innerHTML = '<div class="heap-empty">Heap is empty</div>';
          heapArray.innerHTML = '<span class="empty-placeholder">[ ]</span>';
          return;
        }

        // Render tree structure
        heapTree.innerHTML = "";

        // Level 0 (root)
        const level0 = document.createElement("div");
        level0.className = "heap-level";
        if (heap[0]) {
          const node = createHeapNode(heap[0], 0);
          level0.appendChild(node);
        }
        heapTree.appendChild(level0);

        // Level 1
        if (heap.length > 1) {
          const level1 = document.createElement("div");
          level1.className = "heap-level";
          for (let i = 1; i <= 2 && i < heap.length; i++) {
            level1.appendChild(createHeapNode(heap[i], i));
          }
          heapTree.appendChild(level1);
        }

        // Level 2
        if (heap.length > 3) {
          const level2 = document.createElement("div");
          level2.className = "heap-level";
          for (let i = 3; i <= 6 && i < heap.length; i++) {
            level2.appendChild(createHeapNode(heap[i], i));
          }
          heapTree.appendChild(level2);
        }

        // Render array
        heapArray.innerHTML = "";
        heap.forEach((item, idx) => {
          const val = document.createElement("span");
          val.className = "heap-array-val";
          if (idx === 0) val.classList.add("min");
          val.textContent = item.val;
          heapArray.appendChild(val);
        });
      }

      function createHeapNode(item, index) {
        const node = document.createElement("div");
        node.className = "heap-node";
        node.id = `heap-node-${index}`;
        if (index === 0) node.classList.add("min-node");
        node.textContent = item.val;

        const label = document.createElement("span");
        label.className = "heap-node-label";
        label.textContent = `L${item.listIdx}`;
        node.appendChild(label);

        return node;
      }

      function renderResult() {
        const container = document.getElementById("resultList");
        container.innerHTML = "";

        if (result.length === 0) {
          container.innerHTML =
            '<span class="empty-placeholder">Will build as we extract from heap...</span>';
          return;
        }

        result.forEach((val, idx) => {
          const node = document.createElement("div");
          node.className = "result-node";
          node.textContent = val;
          container.appendChild(node);

          if (idx < result.length - 1) {
            const arrow = document.createElement("span");
            arrow.className = "result-arrow";
            arrow.textContent = "‚Üí";
            container.appendChild(arrow);
          }
        });

        if (currentPhase === "complete") {
          const nullText = document.createElement("span");
          nullText.className = "null-text";
          nullText.style.marginLeft = "5px";
          nullText.textContent = "‚Üí null";
          container.appendChild(nullText);
        }
      }

      function addLog(entry, type = "") {
        logEntries.unshift({ text: entry, type });
        if (logEntries.length > 8) logEntries.pop();

        const container = document.getElementById("logEntries");
        container.innerHTML = "";
        logEntries.forEach((log) => {
          const div = document.createElement("div");
          div.className = "log-entry";
          if (log.type) div.classList.add(`log-${log.type}`);
          div.textContent = log.text;
          container.appendChild(div);
        });
      }

      function updatePhaseIndicator() {
        const phases = ["phase0", "phase1", "phase2"];
        phases.forEach((id, idx) => {
          const el = document.getElementById(id);
          el.className = "phase-badge";

          if (currentPhase === "init" && idx === 0) el.classList.add("active");
          else if (currentPhase === "init" && idx > 0) {
          } else if (currentPhase === "extract" && idx === 0)
            el.classList.add("completed");
          else if (currentPhase === "extract" && idx === 1)
            el.classList.add("active");
          else if (currentPhase === "extract" && idx > 1) {
          } else if (currentPhase === "complete") el.classList.add("completed");
        });
      }

      function setExplanation(text) {
        document.getElementById("explanation").innerHTML = text;
      }

      function setStepCounter(text) {
        document.getElementById("stepCounter").textContent = text;
      }

      let initStep = 0;

      function nextStep() {
        totalSteps++;

        // Phase: Initialize heap with heads
        if (currentPhase === "init") {
          if (initStep < inputLists.length) {
            const listIdx = initStep;
            const val = inputLists[listIdx][0];

            heapPush({ val, listIdx, nodeIdx: 0 });

            addLog(`Push head of L${listIdx}: ${val}`, "insert");

            setStepCounter(`Step ${totalSteps}: Initializing heap`);
            setExplanation(
              `<strong>Initializing Heap</strong><br><br>` +
                `Pushing head of List ${listIdx} (value: <strong>${val}</strong>) into the heap.<br><br>` +
                `<span class="code-display">heap.push({val: ${val}, listIdx: ${listIdx}})</span><br><br>` +
                `Heap now has ${heap.length} element(s). Min at root: ${heap[0].val}`
            );

            initStep++;

            updateInputDisplay();
            renderHeap();

            if (initStep >= inputLists.length) {
              currentPhase = "extract";
              updatePhaseIndicator();
            }
            return;
          }
        }

        // Phase: Extract min and insert next
        if (currentPhase === "extract") {
          if (heap.length === 0) {
            currentPhase = "complete";
            updatePhaseIndicator();
            renderResult();

            setStepCounter("‚úÖ Complete!");
            setExplanation(
              `<strong>üéâ Min-Heap Merge Complete!</strong><br><br>` +
                `Final merged list: <strong>[${result.join(
                  ", "
                )}]</strong><br><br>` +
                `Summary:<br>` +
                `‚Ä¢ Processed ${result.length} total nodes<br>` +
                `‚Ä¢ Each node entered and exited heap exactly once<br>` +
                `‚Ä¢ Each heap operation: O(log k) where k = ${inputLists.length}<br><br>` +
                `Total: <span class="code-display">O(N log k)</span> time, <span class="code-display">O(k)</span> space`
            );

            document.getElementById("stepBtn").disabled = true;
            stopAuto();
            return;
          }

          // Extract minimum
          const min = heapPop();
          result.push(min.val);
          listPointers[min.listIdx]++;

          addLog(`Extract min: ${min.val} from L${min.listIdx}`, "extract");

          // Check if there's a next node in that list
          const nextIdx = min.nodeIdx + 1;
          let insertedNext = false;

          if (nextIdx < inputLists[min.listIdx].length) {
            const nextVal = inputLists[min.listIdx][nextIdx];
            heapPush({ val: nextVal, listIdx: min.listIdx, nodeIdx: nextIdx });
            insertedNext = true;
            addLog(`Push next from L${min.listIdx}: ${nextVal}`, "insert");
          }

          updateInputDisplay();
          renderHeap();
          renderResult();

          setStepCounter(`Step ${totalSteps}: Extract & Insert`);

          let explanation = `<strong>Extract Minimum: ${min.val}</strong> (from List ${min.listIdx})<br><br>`;
          explanation += `<span class="code-display">smallest = heap.pop() // ${min.val}</span><br>`;
          explanation += `<span class="code-display">result.append(${min.val})</span><br><br>`;

          if (insertedNext) {
            const nextVal = inputLists[min.listIdx][nextIdx];
            explanation += `List ${min.listIdx} has more nodes. Push next: <strong>${nextVal}</strong><br>`;
            explanation += `<span class="code-display">heap.push(${nextVal})</span><br><br>`;
          } else {
            explanation += `List ${min.listIdx} exhausted. No insertion.<br><br>`;
          }

          explanation += `Result so far: [${result.join(", ")}]<br>`;
          explanation += `Heap size: ${heap.length}`;
          if (heap.length > 0) {
            explanation += ` | Min: ${heap[0].val}`;
          }

          setExplanation(explanation);
          return;
        }
      }

      function toggleAuto() {
        if (isAutoPlaying) {
          stopAuto();
        } else {
          startAuto();
        }
      }

      function startAuto() {
        isAutoPlaying = true;
        document.getElementById("autoBtn").textContent = "‚è∏ Pause";
        document.getElementById("autoBtn").classList.remove("btn-success");
        document.getElementById("autoBtn").classList.add("btn-warning");

        autoInterval = setInterval(() => {
          if (currentPhase === "complete") {
            stopAuto();
            return;
          }
          nextStep();
        }, getSpeed());
      }

      function stopAuto() {
        isAutoPlaying = false;
        document.getElementById("autoBtn").textContent = "‚èµ Auto Play";
        document.getElementById("autoBtn").classList.remove("btn-warning");
        document.getElementById("autoBtn").classList.add("btn-success");

        if (autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
      }

      function reset() {
        stopAuto();

        currentPhase = "init";
        totalSteps = 0;
        initStep = 0;
        listPointers = [0, 0, 0];
        heap = [];
        result = [];
        logEntries = [];

        document.getElementById("stepBtn").disabled = false;

        initDisplay();
        updateInputDisplay();
        renderHeap();
        renderResult();
        updatePhaseIndicator();

        document.getElementById("logEntries").innerHTML =
          '<div class="log-entry">Waiting to start...</div>';

        setStepCounter("Ready to start!");
        setExplanation(
          `Click <strong>Step</strong> to begin, or <strong>Auto Play</strong> to watch automatically.` +
            `<br><br>` +
            `<strong>Input:</strong> lists = [[1,4,5], [1,3,4], [2,6]]<br>` +
            `<strong>Strategy:</strong> Use a min-heap to always find the smallest element among all list heads in O(log k) time.`
        );
      }

      // Keyboard support
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (currentPhase !== "complete") nextStep();
        } else if (e.code === "KeyR") {
          reset();
        } else if (e.code === "KeyA") {
          toggleAuto();
        }
      });

      // Initialize
      initDisplay();
      updatePhaseIndicator();
    </script>
  </body>
</html>
